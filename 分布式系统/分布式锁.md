### Zookeeper

利用临时顺序子节点来实现，所有客户端在某个节点下创建临时顺序子节点，并在名称上标注读写。

* 共享锁：如果没有比自己更小的节点，或比自己小的节点都是读请求 ，则可以获取到读锁，然后就可以开始读了。
* 排它锁：如果没有比自己更小的节点 ，则表示当前客户端可以直接获取到写锁，对数据进行修改。若发现有比自己更小的节点，无论是读操作还是写操作，当前客户端都无法获取到写锁 ，等待所有前面的操作完成。
* 互斥锁：因为创建节点的唯一性，我们可以让多个客户端同时创建一个临时节点，创建成功的就说明获取到了锁 。然后没有获取到锁的客户端创建一个 watcher 进行节点状态的监听，如果这个互斥锁被释放了，可以调用回调函数重新获得锁。

### Redis

#### SETNX

* 加锁命令：SETNX key value，当键不存在时，对键进行设置操作并返回成功，否则返回失败。key 是锁的唯一标识，一般按业务来决定命名。
* 解锁命令：DEL key，通过删除键值对释放锁，以便其他线程可以通过 SETNX 命令来获取锁。
* 锁超时：EXPIRE key timeout, 设置 key 的超时时间，以保证即使锁没有被显式释放，锁也可以在一定时间后自动释放，避免资源被永远锁住。

#### RedLock

在 Redis Cluster 集群环境下，RedLock 算法加锁步骤如下：

* 获取当前时间戳，单位是毫秒。

* 使用相同的 key 和具有唯一性的 value (例如UUID) 轮流尝试在每个 Master 节点上创建锁，过期时间较短，一般就几十毫秒。

* 如果在大多数节点上建立锁的时间小于超时时间，就算建立成功了。

* 要是锁建立失败了，那么就依次删除之前建立过的锁。
* 只要别人建立了一把分布式锁，你就得**不断轮询去尝试获取锁**。


