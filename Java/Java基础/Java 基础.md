#### 面向对象和面向过程的区别

面向过程：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源。但没有面向对象易维护、易复用、易扩展。

面向对象：面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。缺点是性能比面向过程低。

#### Java 和 C++ 的区别

* 都是面向对象的语言，都支持封装、继承和多态

* Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。

* Java 不提供指针来直接访问内存，程序内存更加安全。

* Java 有自动内存管理机制，不需要程序员手动释放无用内存。

#### 权限修饰符的范围

* `private`：只能在本类中访问。

* `default`：可以在本包所有类中访问。

* `protected`：可以在子类和本包所有类中访问

* `public`：可以在任何地方访问

#### Java面向对象编程三大特性：封装、继承、多态

* 封装：把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法。

* 继承：子类继承父类，可以使用父类的方法，也可以添加新的属性或方法。提高了代码的复用性。

* 多态：意味着一个对象有着多重特征，在不同的条件下，有不同的属性和方法。
  
  实现技术：动态绑定，即在运行时才把方法调用与方法实现关联起来。运行期间通过虚拟机栈的栈帧信息去找到被调用方法的具体实现，然后使用它的直接引用完成方法调用。
  
  Java 中有两种形式可以实现多态：继承和接口。
  

#### this 和 super 关键字

this 关键字用于引用类的当前实例，super 关键字用于从子类访问父类的变量和方法。

#### static 关键字

* 修饰成员变量和成员方法：被 static 修饰的成员属于类，被类中所有对象共享，通过类名调用。

* 静态代码块：用于初试化静态资源，只执行一次。

  > 静态代码块在非静态代码块之前执行 (静态代码块—>非静态代码块—>构造方法)。

* 静态内部类：static 修饰的内部类，属于外部类，只加载一次。

* 静态导包: 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。

#### final 关键字

final 关键字主要用在三个地方：类、方法、变量。

* 当用 final 修饰一个类时，表明这个类不能被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。

* 使用 final 修饰一个方法时，任何继承类都不可以修改它的含义。

* 对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。

#### == 与 equals

* ==：它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象 (基本数据类型比较的是值，引用数据类型比较的是内存地址)。

* equals()：它的作用也是判断两个对象是否相等。但它一般有两种使用情况：

    * 类没有重写 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过 “==” 比较这两个对象。

    * 类重写了 equals() 方法。一般，我们都重写 equals() 方法来比较两个对象的内容是否相等。

#### hashcode 与 equals

hashCode 是为了提高效率，减少可能的比较。当两个对象的 hashCode 相同时，才会调用 equals 方法检查对象是否真的相等。如果 hashCode 不同，就可以直接判断两个对象不相等。

* 如果两个对象相等，则 hashcode 一定也是相同的。
* 两个对象 hashcode 值相等，它们不一定是相等的；但如果 hashcode 值不等，对象一定不相等。
* 因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖，如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等，因为 hashCode() 的默认行为是对堆上的对象产生独特值。

####  重载和重写的区别

* 重载：发生在同一个类中，方法名必须相同，参数顺序、类型、个数不同，方法返回值和访问修饰符也可以不同。
* 重写：重写是子类对父类中的实例方法重新定义功能，发生在子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。（private 方法无法被重写，构造方法无法被重写）

#### 抽象类和接口类的区别

* 抽象类中的成员变量可以是不限制类型的，接口的成员变量只能是 public static final 类型。
* 抽象类中可以有静态代码块与静态方法，而接口不可以。
* 抽象类可以提供成员方法的具体实现，接口不可以 (方法只能是 public abstract 修饰的方法)。
* 一个类只能继承一个抽象类，但可以实现多个接口，接口自己本身可以通过 extends 关键字扩展多个接口。
* 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。

#### 基本数据类型与包装类

| 基本数据类型 | boolean | byte |   char    | short |   int   | long | float | double |
| :----------: | :-----: | :--: | :-------: | :---: | :-----: | :--: | :---: | :----: |
|    包装类    | Boolean | Byte | Character | Short | Integer | Long | Float | Double |
|     字节     |    1    |  1   |     2     |   2   |    4    |  8   |   4   |   8    |

自动装箱：可以把基本数据类型的值或者变量赋值给包装类。

自动拆箱：可以把包装类的变量直接赋值给基本数据类型。

#### 深拷贝和浅拷贝

* 浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。
* 深拷贝：创建一个新的对象，并复制原来对象的内容给新对象。

#### 字符型常量和字符串常量的区别

* 形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的若干个字符
* 含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算；字符串常量代表一个地址值(该字符串在内存中存放位置)
* 占内存大小：字符常量只占 2 个字节；字符串常量占若干个字节 (注意： char 在 Java 中占两个字节)

#### String、StringBuffer、StringBuilder的区别是什么？

* String 中的对象是不可变的，每次操作 String 类型的数据的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。是线程安全的。

    > String 类中使用 final 关键字修饰字符数组来保存字符串，所以 String 对象是不可变的。

* StringBuffer 是对对象本身进行操作。对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。
* StringBuilder 也是对对象本身进行操作，但没有对方法加同步锁，所以不是线程安全的。

#### HashMap 的长度为什么要是 2 的幂次方呢？

寻址时，如果 n 是 2 的幂次方的话，可以用位运算代替取模运算，效率更高。

rehash 时，可以直接判断 `e.hash & oldCap == 1 ? oldCap + i : i`，即如果与运算等于 1，那么 Rehash 的位置就是 oldCap + 之前的下标，如果等于 0 ，那么下标位置不变。

#### HashMap、HashTable 的区别

* HashTable 底层是数组 + 链表，HashMap 底层是数组 + 链表/红黑树。

* HashTable 的键和值都不能为 null。HashMap 可以存储 null 键和 null 值。

* HashTable 线程安全，在修改数据时锁住整个 HashTable。HashMap 线程不安全。

* HashTable 默认初始大小为 11，每次扩容变为原来的 2n + 1。HashMap 初始大小为 16，每次扩容变为原来的 2 倍。 

* HashMap 的迭代器 (Iterator) 是 fail-fast 迭代器，在遍历时如果有其它线程增加或者移除元素时，会抛出 ConcurrentModificationException 异常。而 Hashtable 的 enumerator 迭代器是 fail-safe 的。

  * fail-fast：集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。每当迭代器使用 hashNext()/next() 遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。
  
  * fail-safe：在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。
  
    > HashTable 的迭代器 fail-safe 是因为它不会比较 modCount 值，所以也就不会抛出异常。 

#### Java 序列化中如果有些字段不想进行序列化，怎么办？

对于不想进行序列化的变量，使用 transient 关键字修饰

transient 关键字的作用是：

* 阻止实例中那些用此关键字修饰的的变量序列化；
* 当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。

transient 只能修饰变量，不能修饰类和方法。 

#### Java 反射机制

在程序**运行时**，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性。这种动态的获取信息以及动态调用对象的方法的功能称为 java 的反射机制。

##### Java 反射原理

程序编译生成的 .Class 文件在类加载的时候会在堆上创建一个 Java.lang.class 实例，所有的方法属性都可以通过这个实例获取到。

##### Java 反射调用步骤

* 得到要调用类的 class。
* 得到要调用的类中的方法 (Method)。
* 方法调用 (invoke)。

```java
Class cls = Class.forName("test.reflect.Student");  
Method m = cls.getDeclaredMethod("MethodName",方法参数类);  
m.invoke(类实例,参数);
```

#### Java 异常

Thorwable 类是所有异常和错误的超类，两个直接子类为 Error 和 Exception。

*  Error 是系统错误，它是由 JVM 产生和抛出的，比如内存溢出、线程死锁等情况。这些异常发生时，JVM 一般会选择线程终止。

*  Exception 是程序的异常，分为运行时异常和检查异常。
   
   * 检查异常是在编译期间发现的异常，例如：IOException，FileNotFoundException 等等。
   
   * 运行时异常是在程序运行期间发现的异常，例如：类型错误转换，数组下标访问越界，空指针异常、找不到指定类等等。

异常处理：可以通过 try-catch 捕获异常，也可以通过 throws 声明异常。

