### JVM 内存区域

<img src="/Users/licheng/Documents/Typora/Picture/image-20200423163942082.png" alt="image-20200423163942082" style="zoom:67%;" />

### 程序计数器

记住下一条 JVM 指令的执行地址。

特点：线程私有，不会出现内存溢出。

### 虚拟机栈

* 栈：线程运行需要的内存空间，线程私有。

* 栈帧(Frames)：每个方法运行时需要的内存空间，每个栈由多个栈帧组成。

  > 栈帧包括局部变量表，操作数栈，方法的返回地址，动态链接。
  >
  > 动态链接：符号引用在类加载阶段解析成直接引用，叫做静态解析；在运行阶段解析成直接引用叫做动态链接。

* 每个线程只能有一个活动栈帧，对应当前正在执行的方法。

  > 栈内存溢出 (stackoverflow)：栈帧过多 (递归)。

### 本地方法栈

与虚拟机栈类似，存储本地方法的局部变量表、操作数栈等信息。

> 本地方法：由非 Java 语言实现，用来与操作系统或某些硬件进行交互。

### 堆

通过 new 关键字，创建对象都会使用堆内存。

特点：线程共享，有垃圾回收机制。

> 堆内存溢出 (OutofMemory)

### 方法区

<img src="/Users/licheng/Documents/Typora/Picture/image-20200423104945679.png" alt="image-20200423104945679" style="zoom:67%;" />

方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

#### 文件常量池

就是 .class 文件的一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型和字面量等信息。

常量池中主要存储两类常量：字面量和符号引用。

* 字面量：文本字符串 (String)、Java 中声明为 final 的常量值等等
* 符号引用：类和接口的全局限定名 (Class_info)，字段的名称和描述符 (Fields_info)，方法的名称和描述符(Methods_info)。

常量池的好处：可以避免频繁的创建和销毁对象而影响系统性能，且实现了对象的共享。

#### 运行时常量池

类加载后，常量池中的字面量与符号引用信息就会放入运行时常量池中，并把里面的符号地址变为直接引用。

运行时常量池相对于 .class 文件常量池的另外一个重要特性是具备动态性，也就是说，并非预置入 class 文件中常量池的内容才能进入运行时常量池，运行期间也可以将新的常量放入池中，用的最多的就是 String 类的 `intern()` 方法。

> 不同的类共用一个运行时常量池。
>

#### 字符串常量池 (StringTable)

字符串常量池中存的是引用，引用指向的字符串对象还是存储在堆中。

##### String s = “hello”

```java
public class Hello {
    public static void main(String[] args) {
        String s1 = "hello";
    }
}
```

1. 首先在编译期间，`"hello"`作为字符串的字面量，会被保存在 class 文件的常量池中，具体为一个`CONSTANT_String` 类型的常量指向另一个 `CONSTANT_Utf8` 类型的常量，然后 `CONSTANT_Utf8` 类型的常量中保存着 `hello` 这几个字符的 Unicode 编码。
2. 接着在 Hello.class 文件被加载时，会在方法区中申请一块内存作为 Hello 类的运行时常量池，并将 Hello.class 文件中常量池的内容放进运行时常量池中。注意此时，还没有创建 ”hello” 字符串的任何实例。
3. 接着到执行 `String s1 = "hello";` 时，表示 ”hello” 字面量的`CONSTANT_String`类型的常量会被推到栈顶，此时会发现此常量尚未进入 Resolve 阶段，因此会先执行 Resolve。在 Resolve 阶段，首先会先查看字符串常量池中是否有相同内容的字符串实例的引用，如果有，则直接使用该引用，否则会在堆内存中创建一个新的字符串实例，其内容与`CONSTANT_String`类型的常量所指向`CONSTANT_Utf8`类型的常量中的内容一致，接着将这个引用添加到字符串常量池中，最后返回该引用。
4. 最后将引用赋给 `s1`，打印并 Return。

字符串字面量所表示的字符串对象实例并非一定在类加载阶段实例化。而是在 Resolve 阶段，而 Resolve 阶段的执行是可以延迟的。可以理解为当执行到字面量所在的代码时才会进入 Resolve 阶段 (对应的字节码指令为 ldc)。

##### String s = new String(“hello”)

```java
public class Hello {
    public static void main(String[] args) {
        String s = new String("hello");
    }
}
```

* 若在执行此代码之前，”hello” 字符串已经在字符串常量池中，则只会在堆中创建一个新的字符串实例。
* 如果字符串常量池中没有 ‘’hello’‘’，会先在堆中创建 ”hello” 实例，添加该实例的引用到字符串常量池中，接着根据该实例再创建一个新的内容一致的字符串对象赋值给变量 s。

##### String.intern()

该方法会查看字符串常量池中是否有引用指向该 String 对象，没有则添加该 String 对象的引用到字符串常量池。有则直接返回引用。

### 直接内存

就是堆外内存，不受 JVM 内存回收管理，分配回收成本较高，但读写性能高。

在 Java NIO 时，缓冲区 buffer 使用的就是堆外内存，好处是没有 Java 堆内存大小的限制和垃圾回收，而且避免了内核缓冲区与用户缓冲区相互拷贝的过程，提升了效率。缺点是分配和回收成本比较高，而且存在内存泄漏的风险。

