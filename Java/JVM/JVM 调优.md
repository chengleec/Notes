#### GC调优策略

**尽可能让对象在新生代中分配和回收，尽量避免过多对象进入老年代，导致对老年代频繁进行垃圾回收，同时给系统足够的内存减少新生代垃圾回收次数。**

1. 将新对象预留在新生代

   由于 Full GC 的成本远高于 Minor GC ，因此应尽量将对象分配在新生代，实际项目中根据 GC 日志分析新生代空间是否分配合理，适当通过`-Xmn` 命令来调节新生代大小，最大限度降低新对象进入老年代的情况。

2. 大对象进入老年代

   大对象如果首次在新生代分配可能会出现空间不足导致很多年龄不够的小对象被分配到老年代，导致频繁的`Full GC`。因此，对于大对象，可以设置直接进入老年代。

3. 合理设置进入老年代对象的年龄

   减少老年代的内存占用，降低发生`Full GC`的频率。

#### JVM 调优参数

| 参数                            | 描述                                              |
| ------------------------------- | ------------------------------------------------- |
| -Xms                            | 初始化堆内存大小，默认为物理内存的1/64(小于1GB)。 |
| -Xmx                            | 堆内存最大值                                      |
| -Xss                            | 栈内存大小                                        |
| -XX:MaxMetaspacesize            | 元空间大小                                        |
| -XX:MaxDirectMemorySize=1G      | 直接内存大小                                      |
| -Xmn                            | 新生代大小，包括Eden区与2个Survivor区。           |
| -XX:SurvivorRatio=8             | Eden 区与一个 Survivor 区的比例                   |
| -XX:NewRatio=2                  | 设置新生代和老年代的比例，默认 2:1                |
| -XX:+PrintDCDetails -verbose:gc | 打印 GC 详情                                      |

#### 调优工具

* jps：查看当前系统中有哪些 java 进程

* jstack pid：查看进程中各线程的详细信息，经常用来排除死锁情况。

* jstat：检测 Java 程序运行的实时情况，包括堆内存信息和垃圾回收信息，我们常常用来查看程序垃圾回收情况。常用的命令是 jstat -gc pid。

  ![image-20200616202255875](/Users/licheng/Documents/Typora/Picture/image-20200616202255875.png)

  | 字段 | 描述                                                     |
  | ---- | -------------------------------------------------------- |
  | S0C  | 年轻代中 To Survivor 的容量（单位 KB）                   |
  | S1C  | 年轻代中 From Survivor 的容量（单位 KB）                 |
  | S0U  | 年轻代中 To Survivor 目前已使用空间（单位 KB）           |
  | S1U  | 年轻代中 From Survivor 目前已使用空间（单位 KB）         |
  | EC   | 年轻代中 Eden 的容量（单位 KB）                          |
  | EU   | 年轻代中 Eden 目前已使用空间（单位 KB）                  |
  | OC   | 老年代的容量（单位 KB）                                  |
  | OU   | 老年代目前已使用空间（单位 KB）                          |
  | MC   | 元空间的容量（单位 KB）                                  |
  | MU   | 元空间目前已使用空间（单位 KB）                          |
  | YGC  | 从应用程序启动到采样时年轻代中 gc 次数                   |
  | YGCT | 从应用程序启动到采样时年轻代中 gc 所用时间 (s)           |
  | FGC  | 从应用程序启动到采样时老年代（Full Gc）gc 次数           |
  | FGCT | 从应用程序启动到采样时老年代代（Full Gc）gc 所用时间 (s) |
  | GCT  | 从应用程序启动到采样时 gc 用的总时间 (s)。               |

* jmap
  
  * jmap -heap pid：查看堆内存占用情况 (某个时刻)。
  * jmap -histo pid： 显示堆中对象的统计信息 (按照类占用内存大小降序排列)。
  * jmap  -clstats pid：打印类加载器信息。
* jconsole：

* jvisualvm：

#### 常见问题示例

* CPU占用过多
  1. top：查看哪个进程对 CPU 的占用过高
  2. ps H -eo pid,tid,%cpu | grep pid：用 ps 命令进一步定位哪个线程引起的CPU占用过高
  3. jstack pid：可以根据线程 id 找到有问题的线程，进一步定位问题代码的源码行号

* 程序运行后迟迟得不到结果：使用 jstack 查看是否发生了死锁。

* 数据分析平台系统频繁 Full GC

平台主要对用户在APP中行为进行定时分析统计，并支持报表导出，使用CMS GC算法。数据分析师在使用中发现系统页面打开经常卡顿，通过jstat命令发现系统每次Young GC后大约有10%的存活对象进入老年代。

原来是因为Survivor区空间设置过小，每次Young GC后存活对象在Survivor区域放不下，提前进入老年代，通过调大Survivor区，使得Survivor区可以容纳Young GC后存活对象，对象在Survivor区经历多次Young GC达到年龄阈值才进入老年代，调整之后每次Young GC后进入老年代的存活对象稳定运行时仅几百Kb，Full GC频率大大降低