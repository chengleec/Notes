### 如何判断对象可以回收：

#### 引用计数法

给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；计数器为 0 表示对象可以回收了。

缺点：很难解决对象之间循环引用问题。

#### 可达性分析法

以 "GC Roots" 对象作为起点开始向下搜索，所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。

> GC ROOT 对象：本地方法栈中引用的对象，虚拟机栈中的引用对象（活动线程中用到的对象），方法区中类静态属性引用的对象和常量引用对象。

### 引用

* 强引用（StrongReference）

   像 `Object obj = new Object()` 这种，只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。 

* 软引用（SoftReference）

  仅有软引用该对象时，在垃圾回收后，内存仍不足时会再次垃圾回收，回收软引用对象。

* 弱引用（WeakReference）

  被弱引用引用的对象只能生存到下一次垃圾收集前，一旦发生垃圾收集，被弱引用所引用的对象就会被清掉。

* 虚引用（PhantomReference）

  当被一个虚引用引用的对象被回收时，系统会收到这个对象被回收了的通知 (对对象没有一丁点儿影响，只是标记作用)。

### 垃圾收集算法

#### 标记-清除算法

首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

它是最基础的收集算法，这种垃圾收集算法会带来两个明显的问题：

* 效率问题
* 空间问题 (标记清除后会产生大量不连续的碎片)

#### 标记-整理算法

首先标记出所有需要回收的对象，然后让所有存活的对象向一端移动，最后直接清理掉边界以外的内存。

缺点：存在效率问题，适合老年代。

#### 标记-复制算法

将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。

缺点： 可用内存缩小为原来的一半，适合 GC 过后只有少量对象存活的新生代。

优化：新生代中的对象 98% 都是朝生夕死的，所以不需要按照 1:1 的比例对内存进行划分。

* 把内存划分为 1 块比较大的 Eden 区和 2 块较小的 Survivor 区。每次使用 Eden 区和 1 块 Survivor 区。
* 回收时，将以上 2 部分区域中的存活对象复制到另一块 Survivor 区中，然后将以上两部分区域清空。
* 默认比例：8:1:1

#### 分代收集算法

* 新生代： GC 过后只有少量对象存活 —— **优化后的复制算法**
* 老年代： GC 过后对象存活率高 —— **标记 - 整理算法**

新生代晋升老年代条件

* 虚拟机给每个对象定义一个年龄计数器，对象每在 Survivor 中熬过一次 Minor GC，年龄 +1，达到 `-XX:MaxTenuringThreshold` 设定值后，会被晋升到老年代，`-XX:MaxTenuringThreshold` 默认为 15；
* 当大对象在 Eden 区放不下时，会通过分配担保机制将对象转移到老年代中。可以通过` -XX:PretenureSizeThreshold` 设置直接进入老年代的对象大小。

Minor GC：新生代垃圾回收。一般填满 Eden 区就会进行。

Major GC：老年代垃圾回收。

Full GC：整个 Java 堆垃圾回收。触发条件为：

* 显式调用 `System.gc()` 方法
* 老年代空间不足：如果年轻代发生了 gc，一部分存活的对象需要进入老年代，但老年代没有足够的空间容纳晋升的对象，因此晋升失败，进而发生 Full GC。

### HotSpot 算法细节实现

<img src="/Users/licheng/Documents/Typora/Picture/image-20200625102036543.png" alt="image-20200625102036543" style="zoom:67%;" />

#### GC Roots

可达性分析的第一步，就是要枚举 GC Root。所以为了提高 GC 的效率，HotSpot 使用了一种 OopMap 的数据结构，OopMap 记录了栈上本地变量到堆上对象的引用关系，GC 的时候就不用遍历整个栈，只遍历每个栈的 OopMap 就行了。

#### Remember Set

记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构，垃圾收集器会在新生代中建立用以避免把整个老年代加进 GC Roots 扫描范围。

> 比如新生代的垃圾回收，除了要将虚拟机栈中指向新生代的对象设置为 GC Roots 之外，还需要将新生代中指引用老年代的对象作为 GC Roots，如果遍历整个老年代效率会很低，所以采用记忆集将跨代引用的对象都记录下来，这样只需要扫描记忆集就可以了，不用扫描整个老年代。
>
> 老年代同理，老年代垃圾回收前最好进行一次 Minor GC，减少新生代到老年代的引用数量。

##### Card Table

卡表是记忆集的一种具体实现，他定义了记忆集的记录精度，与堆内存的映射关系。

卡表的底层是基于一个名为 CARD_TABLE 的字节数组来实现的，CARD_TABLE 的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作 “卡页” (Card Page)。

一个卡页的内存中通常包含不止一个对象，只要卡页有一个或者多个对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为 1，称为这个元素变脏 (Dirty)，没有则标识为 0。垃圾收集时，只要筛选出卡表中变脏的元素 ，就可以得出哪些卡页内存块中包含跨代指针，把他们加入 GC Roots 中一并扫描。

> CMS 使用写后屏障来维护卡表，记录的是我指向谁。
>
> G1 收集器的每个 Region 都会维护有自己的记忆集，记忆集会记录下别的 Region 指向自己的指针 (谁指向我)。G1 的记忆集在存储结构的本质上是一种哈希表， Key 是别的 Region 的起始地址，Value 是一个集合，里面存储的元素是卡表的索引号。G1 也使用写后屏障来维护卡表。

#### 安全点

但如果执行完一条指令就更新下 OopMap，这 GC 成本实在太高了。HotSpot 采用了一种在 “安全点” 更新 OopMap 的方法。安全点位置的选取基本上是以 “是否具有让程序长时间执行的特征” 为标准进行选定的。 “长时间执行” 的最明显特征就是指令的序列的复用，例如：方法调用、循环跳转、异常跳转等，虚拟机一般会将这些地方设置为安全点，更新 OopMap 并判断是否需要进行 GC 操作。

**我们如何让所有线程跑到最近的安全点再停顿下来进行 GC 操作呢？**

* 抢先式中断：
  * 先中断所有线程；
  * 发现有线程没中断在安全点，恢复它，让它跑到安全点。
* 主动式中断：(主要使用)
  * 设置一个中断标记；
  * 每个线程到达安全点时，检查这个中断标记，选择是否中断自己。

#### 安全区域

一个处于 Sleep 或者 Blocked 状态的线程是没办法自己到达安全点中断自己的，对于这种情况，我们要依靠安全区域来解决。

安全区域是指在一段代码片段之中，引用关系不会发生变化，因此在这个区域中的任意位置开始 GC 都是安全的。

当线程执行到安全区域时，它会把自己标识为 Safe Region，这样 JVM 发起 GC 时是不会理会这个线程的。当这个线程要离开安全区域时，它会检查系统是否在 GC 中，如果不在，它就继续执行，如果在，它就等 GC 结束再继续执行。

#### 可达性分析

##### 三色标记法

把遍历对象图过程中遇到的对象，按照 “是否访问过” 这个条件标记成以下三种颜色：

* 黑色：对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。

* 灰色：表示这个对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。

* 白色：对象尚未被垃圾收集器访问过。

标记步骤：

1. 最开始所有对象都是白色的，然后把 GC Root 对象置为灰色。
2. 第二步把灰色的对象全部置为黑色，然后把原先灰色对象指向的变量都置为灰色，以此类推。
3. 当没有对象可以被置为灰色时，所有的白色变量就一定是需要被清理的垃圾了。

##### 可达性分析实现

但在并发收集的情况下，收集器在对象图上标记颜色，同时用户线程在修改引用关系，这种可能出现两种后果：

* 原本消亡的对象标记为存活，可以容忍，下次在回收就是了。
* 原本存活的对象标记为消亡，会导致程序出错。

Wilson 于 1994 年理论上证明了，当且仅当以下两个条件同时满足时，会产生 “对象消失的问题”，即原本应该是黑色的对象被误标记为白色。

* 赋值器插入了一条或多条从黑色对象到白色对象的新引用。
* 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。

因此，我们要解决并发扫描时对象消失的问题，只需破坏这两个条件的任意一个即可。

**增量更新** (Incremental Update)

CMS 使用的策略，增量更新破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用的关系时，就将这个新插入的引用记录下来，等并发扫描结束时，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。

**原始快照** (Snapshot At The Beginning, SATB)

G1 使用的策略，原始快照破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就要将这个要删除的引用关系记录下来，等在并发扫描结束之后，再将这些记录过的引用关系的灰色对象为根，重新扫描一次。即无论引用关系删除与否，都会按照**刚开始扫描那一刻的对象图**快照来进行搜索。

> G1 使用写前屏障来维护这种引用关系。

G1 为每个 Region 设计了两个名为 TAMS (Top at Mark Start) 的指针，把 Region 中的一部分空间划分出来用于并发回收过程中新创建对象的内存分配，并发回收时新分配的对象地址都必须在这两个指针位置以上。G1 收集器默认在这个地址以上的对象是被隐式标记过得，即默认他们是存活的，不纳入回收范围。

> 新创建的对象在原始对象图中是没有的，所以必须单独处理。

### 垃圾收集器

#### 串行收集器 (Serial + Serial Old)

##### Serial 收集器

单线程收集器，采用复制算法，使用一条垃圾收集线程去完成垃圾收集工作，而且它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ "Stop The World" ）。

##### Serial Old 收集器

Serial 收集器的老年代版本，采用标记-整理算法，它同样是一个单线程收集器，一般作为 CMS 收集器的后备方案。

#### 吞吐量优先 (Parallel Scavenge + Parallel Old)

##### Parallel Scavenge 收集器

并行的多线程新生代收集器。

##### Parallel Old 收集器

Parallel Scavenge 收集器的老年代版本。其他收集器关注于尽可能缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目的是达到一个可控的吞吐量。

> 吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )

因此，Parallel Scavenge 收集器不管是新生代还是老年代都是多个线程同时进行垃圾收集，十分适合于应用在注重吞吐量以及 CPU 资源敏感的场合。

JVM 参数设置：

* `-XX:GCTimeRatio`：吞吐量大小，一个 0 ~ 100 的数，默认99%。

  > 最大 GC 时间占总时间的比率 = 1 / (GCTimeRatio + 1)

* `-XX:+UseAdaptiveSizePolicy`：一个开关参数，打开后就无需手工指定 `-Xmn`，`-XX:SurvivorRatio` 等参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，自行调整。

#### 响应时间优先 (ParNew + CMS)

##### ParNew 收集器

ParNew 收集器其实就是 Serial 收集器的多线程版本，与 CMS 配合使用。

ParNew 主要工作在 Server 模式，我们知道服务端如果接收的请求多了，响应时间就很重要了，多线程可以让垃圾回收得更快，也就是减少了 STW 时间，能提升响应时间，所以是许多运行在 Server 模式下的虚拟机的首选新生代收集器。

##### CMS（Concurrent Mark Sweep）收集器

并发的老年代收集器，采用**标记-清除**算法，是一种以获取最短回收停顿时间为目标的收集器，整个过程分为4个步骤：

<img src="/Users/licheng/Documents/Typora/Picture/image-20200423224939345.png" alt="image-20200423224939345" style="zoom:50%;" />

1. 初始标记： 暂停所有的其他线程，并记录下直接与 GC Root 相连的对象，速度很快。

2. 并发标记： 同时开启 GC 和用户线程，从 GC ROOT 继续向下进行标记，但用户线程会继续更新对象的引用域。

3. 重新标记：为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。

   > CMS 大部分时间都花费在重新标记阶段，可以让虚拟机先进行一次 Young GC，减少停顿时间。

4. 并发清除： 开启用户线程，同时 GC 线程开始对为标记的区域做清扫。

**concurrent mode failure**

这个异常发生在 CMS 正在回收的时候。执行 CMS GC 的过程中，同时业务线程也在运行，当年轻带空间满了，执行 young gc 时，需要将存活的对象放入到老年代，而此时老年代空间不足，这时 CMS 还没有机会回收老年代，就会抛出这个异常。

JVM 参数设置：

* `-XX:+UseCMSCompactAtFullCollection`：在 CMS 要进行 Full GC 时进行内存碎片整理（默认开启）

* `-XX:CMSFullGCsBeforeCompaction`：在多少次 Full GC 后进行一次空间整理（默认是 0，即每一次 Full GC 后都进行一次空间整理）

* `-XX:CMSInitiatingOccupancyFraction=70`：设定 CMS 在对内存占用率达到 70% 的时候开始 GC。

  > 由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。

#### G1收集器

将堆内存分成大小相等的 Region，并维护一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region。

> 整体使用的是标记-整理算法，区域之间使用的是复制算法。

整个过程分为 4 个步骤：

1. 初始标记：标记与 GC Roots 直接相连的对象，并且修改 TAMS 指针的值。
2. 并发标记：从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆。当对象图扫描完成后，还要重新处理 SATB 记录下的在并发时有引用变动的对象。
3. 最终标记：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的 SATB 记录。
4. 筛选回收：负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来执行回收计划。这里采用复制算法，将要回收的 Region 集合中存活的对象复制到空的 Region 中，在清理掉整个旧 Region 的全部空间。

与 CMS 相比，它在以下两个方面表现更出色：

* 运作期间不会产生内存碎片，G1 从整体上看采用的是标记-整理法，局部 (两个 Region) 上看是基于复制算法实现的，两个算法都不会产生内存碎片，收集后提供规整的可用内存，这样有利于程序的长时间运行。
* 建立了**可预测**的停顿时间模型，用户可以指定期望停顿时间，G1 会将停顿时间控制在用户设定的停顿时间以内

JVM 参数设置：

`-XX:G1HeapRegionSize`：Region 大小，取值范围为 1 MB ~ 32 MB，必须为 2 的 N 次幂。

`-XX:MaxGCPauseMillis`：设定收集停顿时间，默认是 200 毫秒。

>并行：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
>并发：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。
