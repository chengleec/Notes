### 双亲委派模型

* BootstrapClassLoader(启动类加载器) ：最顶层的加载类，由 C++ 实现，负责加载  JAVA_HOME/jre/lib 目录下的类

  >  可以指定 -Xbootclasspath 参数，该路径下的类也会被 BootstrapClassLoader 加载。

* ExtensionClassLoader(扩展类加载器) ：主要负责加载目录 JRE_HOME/jre/lib/ext 目录下的类

  > 可以设置 java.ext.dirs 系统变量，让 ExtensionClassLoader 加载该路径下的类。

* ApplicationClassLoader(应用程序类加载器) :面向用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。

在类加载的时候，先不自己尝试加载类，而是先将请求委派父类加载器完成。因此所有的请求最终都会传送到顶层的启动类加载器 BootstrapClassLoader 中。只有当父类加载器加载失败时，子类加载器才会尝试自己去加载。

双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载，也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现多个不同的 Object 类。

****

### Java 类加载时机

* 使用 new 关键字实例化对象的时候。
* 访问一个类的静态方法和静态变量的时候。
* 子类初始化时如果发现父类还未初始化，会先触发父类的初始化，然后初始化子类。

* 虚拟机启动时，会先初始化包含 main() 函数的主类。
* 使用 java.lang.reflect 包的方法对类进行反射调用的时候。
* 当接口中定义了被 default 关键字修饰的方法，且接口的实现类发生了初始化，会先触发接口的初始化。

#### 显式加载

*  `Class.forName(className)` ：借助当前调用者的 ClassLoader 完成类的加载，加载时会初始化静态变量和静态代码块。

*  `ClassLoader.loadClass(className)`：将 .class 文件加载到 JVM 中，不会初始化静态变量和静态代码块，只有在 new 实例化对象的时候才会去执行。

### Java 类加载过程

虚拟机把描述类的数据从 .class 文件加载到内存，加载过程分为 3 步：加载、链接（验证、准备、解析）、初始化。

#### 加载

* 通过类的全限定名 (如cn.edu.hust.test.HelloWorld.class) 获取定义此类的二进制字节流 (将 .class 文件读进内存)。

* 将字节流所代表的静态存储结构转换为方法区运行时数据结构。

* 在堆内存中生成一个代表该类的 java.lang.Class 对象，作为方法区中这个类的各种数据的访问入口。

#### 验证

验证 .class 文件中的字节流信息符合虚拟机的要求。

#### 准备

正式为静态变量分配空间，设置默认值。

static 变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成。

* 如果是 static final 基本类型，或者是 String 类型，那么编译阶段值就确定了，赋值在准备阶段完成。

* 如果是 static final 引用类型，赋值会在初始化阶段完成，准备阶段只分配空间。

#### 解析

虚拟机将常量池内的一部分符号引用替换为直接引用的过程，也就是得到类、字段、方法在内存中位置的过程。

#### 初始化

初始化类的静态变量和静态代码块。

****

### 创建对象过程

创建对象的方法：new、clone、反射。

#### 类加载检查

虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

#### 分配内存

在类加载检查通过后，接下来虚拟机将为新生对象分配内存。此时已经可以确定存储这个对象所需的内存大小。

* 指针碰撞：用过的内存整合到一边，没有用过的内存放在另一边，中间有一个分界值指针，只要向着没用的内存方向将该指针移动对象内存大小位置即可。用于内存规整的情况。
* 空闲列表：虚拟机会维护一个列表，该列表中会记录哪些内存是可用的，再分配的时候，找一块足够大的内存块来划分给对象实例，最后更新列表记录。用于堆内存不规整的情况。

#### 初始化对象信息

初始化零值、设置对象头 (hashCode、分代年龄信息)、对象赋值。

#### 将对象的地址赋值给引用

