### 并发编程的3个重要特性

* 原子性：一个或多个操作，要么全部执行且在执行过程中不被任何因素打断，要么全部不执行。
* 可见性：当一个线程修改了共享变量的值，其他线程能够立即看到修改的值。
* 有序性：程序执行是按照代码的先后顺序执行的。

### Java 内存模型

Java 内存模型定义了程序中各种变量（实例字段、静态字段、构成数组对象的元素）的访问规则。

* JMM 规定所有的变量都存储在主内存中，线程不能直接修改主内存中的变量的值。

* 每个线程有自己的工作内存来存储主内存中的变量副本。线程只能操作这个变量副本。

* 不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递（通信）均需要通过主内存来完成。

这就可能造成一个线程修改了一个变量的值，而另外一个线程还在使用它之前的副本值，造成数据的不一致。

### Volatile 底层原理

volatile 修饰的共享变量进行写操作的时候会多执行一条 `lock` 前缀的指令，`lock` 指令会将当前 CPU 的缓存写入内存，并且无效化其他 CPU 的缓存。其他 CPU 在读取 volatile 变量时，会发现自己的缓存过期了，于是会去主内存中拉取最新的 volatile 变量值，这使得其他 CPU 可以立即看见 volatile 变量的修改。

`lock` 的存在还相当于一个内存屏障，在重排序时，不能把内存屏障后面的指令排在内存屏障前面。

内存屏障的分类：

* 读屏障：Load Barrier，在读指令前插入读屏障，可以让高速缓存中的数据失效，重新从主内存加载数据，以保证读取的是最新的数据。
* 写屏障：Store Barrier，在写指令后插入写屏障，能让写入缓存的最新数据写回到主内存，以保证写入的数据立刻对其他线程可见。
* 全能屏障：同时具备读屏障和写屏障的功能。

### as-if-serial

不管怎么重排序 (编译器和处理器为了提高并行度)，(单线程) 程序的执行结果不会改变。

### happen-before 原则（先行发生）

Happens-Before 规则本质上是一种顺序约束规范，用来约束编译器的优化行为。就是说，为了执行效率，我们允许编译器的优化行为，但是为了保证程序运行的正确性，我们要求编译器优化后需要满足 Happens-Before 规则。

* 程序次序规则：**一个线程内**，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。
* 传递规则：如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C。
* Monitor 锁定规则：一个 unLock 操作先行发生于后面对同一个锁的 lock 操作。
* volatile 变量规则：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。
* 线程启动规则：Thread 对象的`start()`方法先行发生于此线程的每个一个动作。
* 线程中断规则：对线程`interrupt()`方法的调用先行发生于被中断线程的代码检测到中断事件的发生。即对一个线程的 `interrupt()` 操作和 `interrupted()` 等检测中断的操作同时发生，那么 `interrupt()` 先执行。
* 线程终止规则：线程中所有的操作都先行发生于线程的终止检测。
* 对象终结规则： 对象的构造函数执行先于 `finalize()` 方法。
