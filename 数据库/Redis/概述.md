### 简介

Redis 是一个开源的、使用 C 语言编写的、基于内存、可持久化的 Key-Value 数据库，value 支持丰富的数据类型，包括 string、list、hash、set、zset。速度快，性能高。

### Redis 特性

#### 单线程

因为 Redis 是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了。

#### 高性能

*  Redis 是单线程的，省去了很多上下文切换线程的时间；
*  Redis 是基于内存的，内存的读写速度非常快；
* 数据结构专门设计。比如 SDS 结构中字符串长度 len，压缩列表等。
*  Redis 使用 I/O 多路复用技术，可以处理并发的连接。Redis 中“多路”指的是多个网络连接，“复用”指的是复用同一个线程。

### 消息处理流程

* 文件事件处理器使用 I/O 多路复用来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。
* 当被监听的套接字就绪后，就会产生相应的文件事件，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。

* 所有产生事件的套接字都放入一个队列里面，然后通过这个队列，以有序、同步、每次一个套接字的方式向文件事件分派器传送套接字，即当上一个套接字产生的事件被处理完毕之后， I/O 多路复用程序才会继续向文件事件分派器传送下一个套接字。

### 缓存淘汰策略

#### 检测易失数据 (设置了过期时间的)

* volatile-lru：挑选最近最少使用的数据淘汰
* volatile-ttl：挑选将要过期的数据淘汰
* volatile-random：任意选择数据淘汰

#### 检测全库数据

* allkeys-lru：挑选最近最少使用的数据淘汰
* allkeys-random：任意选择数据淘汰

#### 放弃数据驱逐

* no-enviction（驱逐）：禁止驱逐数据（ Redis4.0 中默认策略），会引发错误 OOM。

### 过期策略

Redis 默认采用定期删除 + 惰性删除策略来删除设置了过期时间的那些数据。

* 定时删除：创建一个定时器，当 key 设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作。
* 惰性删除：获取某个 key 的时候， Redis 会检查一下，如果发现已过期，就删除，返回不存在。
* 定期删除： Redis 默认每隔 100ms 检查一次，采用随机抽取的策略，如果删除过期 key 的数量大于抽取的 25%，则循环抽取，否则进入下一个数据库。

### 持久化机制

#### RDB

将内存的数据以快照的形式保存到磁盘中。

Redis 会 `fork `一个子进程，快照的持久化就交给子进程去处理，而父进程继续处理线上业务的请求。

RDB 的 SAVE 和 BGSAVE

* SAVE 是阻塞式持久化，执行命令时 Redis 主进程把内存数据写入到 RDB 文件中直到创建完毕，期间 Redis 不能处理任何命令。
* BGSAVE 属于非阻塞式持久化，创建一个子进程把内存中数据写入 RDB 文件里同时主进程处理命令请求。

#### AOF (append only file)

将 Redis 执行的写命令记录到日志文件中，当重启 Redis 时重新执行日志文件中的写命令。

当开启 AOF 后，服务端每执行一次写操作就会把该条命令追加到一个单独的 AOF 缓冲区的末尾，然后把 AOF 缓冲区的内容写入 AOF 文件里，由于磁盘缓冲区的存在，写入 AOF 文件之后，并不代表数据已经落盘了，而何时进行文件同步则是根据配置的 appendfsync 来进行配置：

* always：服务器在每执行一个事件就把 AOF 缓冲区的内容强制性的写入硬盘上的AOF文件里，保证了数据持久化的完整性，效率是最慢的但最安全的。
* everysec：服务端每隔一秒才会进行一次文件同步把内存缓冲区里的AOF缓存数据真正写入 AOF 文件里，兼顾了效率和完整性，极端情况服务器宕机只会丢失一秒内对Redis数据库的写操作。
* no：表示默认系统的缓存区写入磁盘的机制，不做程序强制，数据安全性和完整性差一些。


#### 混合持久化

将 RDB 文件和 AOF 结合，AOF 不需要保存全量日志，只需要保存前一次 RDB 存储到现在的存储增量即可。

<img src="/Users/licheng/Documents/Typora/Picture/image-20200606144619464.png" alt="image-20200606144619464" style="zoom:67%;" />

### Redis 实现队列

#### 异步队列

一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。

如果不用 sleep，list 还有个指令叫 blpop，在没有消息的时候，它会阻塞住直到消息到来。

#### 延时队列

可以使用 ZSet，用时间戳作为 Score，消息内容作为 key。调用 `zadd` 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据进行处理。

### 缓存与数据库的双写一致性

#### Cache Aside Pattern

最经典的缓存 + 数据库读写的模式，就是 Cache Aside Pattern。

* 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
* 更新的时候，**先更新数据库，然后再删除缓存**。

**为什么是删除缓存，而不是更新缓存？**

最好用到缓存才去算缓存。如果某个数据在 1 分钟内就修改了 20 次，那么缓存更新 20 次。但是这个缓存在 1 分钟内只被读取了 1 次，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。

**先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。**

先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。

或者设置 key 的过期时间。只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。

#### 订阅 binlog

通过订阅 binlog 来更新 Redis，把我们搭建的消费服务，作为 MySQL 的一个 Slave，订阅 binlog，解析出更新内容，再更新到 Redis。

优点：在MySQL压力不大情况下，延迟较低；和业务完全解耦；解决了时序性问题。

缺点：要单独搭建一个同步服务，并且引入 binlog 同步机制，成本较大。

### 企业级问题解决方案

#### 缓存穿透

用户频繁访问缓存和数据库中都不存在的数据，导致对数据库服务器造成压力（黑客攻击）。

* 缓存空值：将这些 key 对应的值设置为 null 丢到缓存里面去。后面再出现查询这个 key 的请求的时候，直接返回 null。(记得设置过期时间，否则会导致正常情况下也无法使用。)

  适用于 key 的数量有限，重复率比较高的情况。

* 布隆过滤器：在缓存之前在加一层 BloomFilter ，在查询的时候先去 BloomFilter 去查询 key 是否存在，如果不存在就直接返回，存在再去查缓存、查数据库。

  适用于 key 异常多、请求重复率比较低的数据。

#### 缓存击穿

单个高热数据过期的瞬间，数据访问量较大，未命中 Redis 后，发起了大量对同一数据的数据库访问，导致对数据库服务器造成压力。

* 采用分布式锁，只有拿到锁的第一个线程去请求数据库，然后插入缓存。后面的线程进来发现已经有缓存了，就直接走缓存。
* 设置热点数据永不过期。

#### 缓存雪崩

缓存同一时间大面积失效，导致后面的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。

* 分布式锁。
* 设置缓存超时时间的时候加上一个随机的时间长度，比如这个缓存 key 的超时时间是固定的 5 分钟加上随机的 2 分钟，可从一定程度上避免雪崩问题。







