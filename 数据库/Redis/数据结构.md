### 简单动态字符串 (simple dynamic string，SDS)

#### SDS 结构

<img src="/Users/licheng/Documents/Typora/Picture/image-20200715091715127.png" alt="image-20200715091715127" style="zoom:80%;" />

* len：记录当前已使用的字节数 (不包括`'\0'`)，获取 SDS 长度的复杂度为 O(1)。

* alloc：记录当前字节数组总共分配的字节数量 (不包括`'\0'`)。

* flags：标记当前字节数组的属性，是`sdshdr8`还是`sdshdr16`等等。

  ```c
  // flags值定义
  #define SDS_TYPE_5  0
  #define SDS_TYPE_8  1
  #define SDS_TYPE_16 2
  #define SDS_TYPE_32 3
  #define SDS_TYPE_64 4
  ```

* buf：字节数组，用于保存字符串，包括结尾空白字符`'\0'`。

#### SDS 与 C 字符串的区别

##### 常数复杂度获取字符串长度

C 字符串不记录字符串长度，获取长度必须遍历整个字符串，复杂度为O(N)；SDS 结构中本身就有记录字符串长度的`len`属性，复杂度为 O(1)。

##### 可以避免缓冲区溢出

C 字符串不记录自身的长度，如果是拼接操作可能会产生缓存区溢出；当 SDS 需要对字符串进行修改时，首先借助于 len 和 alloc 检查空间是否满足修改所需的要求，如果空间不够的话，SDS 会自动扩展空间。

##### 有效降低内存分配次数

因为 C 字符串并不记录自身的长度， 所以对于一个包含了 N 个字符的 C 字符串来说， 这个 C 字符串的底层实现总是一个 N+1 个字符长的数组。因为 C 字符串的长度和底层数组的长度之间存在着这种关联性， 所以每次增长或者缩短一个 C 字符串， 程序都总要对保存这个 C 字符串的数组进行一次内存重分配操作 (先释放再申请)：

* 如果程序执行的是增加字符串的操作， 比如拼接操作 (append)， 那么在执行这个操作之前， 程序需要先通过内存重分配来扩展底层数组的空间大小 —— 如果忘了这一步就会产生缓冲区溢出。
* 如果程序执行的是缩短字符串的操作， 比如截断操作 (trim)， 那么在执行这个操作之后， 程序需要通过内存重分配来释放字符串不再使用的那部分空间 —— 如果忘了这一步就会产生内存泄漏。

SDS 使用了空间预分配和惰性空间释放机制，说白了就是每次在扩展时多分配空间，在缩短时也是先留着并不正式归还给 OS。

##### 二进制安全

C 语言字符串只能保存 ASCII 码，对于图片、音频等信息无法保存；SDS 是二进制安全的，写入什么读取就是什么，不做任何过滤和限制。

### 压缩列表 (ZipList)

压缩列表 (ziplist) 是链表 (List) 和哈希 (Hash) 的底层实现之一。当一个列表键只包含少量列表项， 并且每个列表项要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用压缩列表来做链表的底层实现。

<img src="/Users/licheng/Documents/Typora/Picture/image-20200715100049976.png" alt="image-20200715100049976" style="zoom:80%;" />

* zlbytes：记录整个压缩列表占用的字节数，在压缩列表内存重分配，或者计算 zlend 的位置时使用。

* zltail：记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，通过该偏移量，可以不用遍历整个压缩列表就可以确定表尾节点的地址。

* zllen：记录压缩列表包含的节点数量，但该属性值小于 UINT16_MAX (65535) 时，该值就是压缩列表的节点数量，否则需要遍历整个压缩列表才能计算出真实的节点数量。

* entryX：压缩列表的节点

* zlend：特殊值 0xFF (十进制255)，用于标记压缩列表的末端。

* previous_entry_length：记录压缩列表前一个节点的长度。

  > 如果前一节点的长度小于 254 字节， 那么 `previous_entry_length` 属性的长度为 `1` 字节；如果前一节点的长度大于等于 254 字节， 那么 `previous_entry_length` 属性的长度为 5 字节。

* encoding：保存节点内容的类型和长度。

* content：保存节点的内容，可以是字节数组和各种类型的整数。

### 链表 (LinkedList)

#### 链表结构

<img src="/Users/licheng/Documents/Typora/Picture/image-20200715094303926.png" alt="image-20200715094303926" style="zoom:67%;" />

* head：表头指针
* tail：表尾指针
* len：链表长度
* dup：用于复制链表节点所保存的值
* free：用于释放链表节点所保存的值
* match：用于对比链表节点所保存的值和另一个输入值是否相等

#### 链表特性

* 双端链表：带有指向前置节点和后置节点的指针，获取这两个节点的复杂度为 O(1)

* 无环：表头节点的`prev`和表尾节点的`next`都指向NULL，对链表的访问以 NULL 结束

* 链表长度计数器：带有`len`属性，获取链表长度的复杂度为O(1)

* 多态：链表节点使用 `void*`指针保存节点值，可以保存不同类型的值

### 字典 (dict)

#### 字典结构

<img src="/Users/licheng/Documents/Typora/Picture/image-20200715101855209.png" alt="image-20200715101855209" style="zoom:80%;" />

##### dict

* type：指向 dictType 结构的指针。

* privdata：配合 type 指向的函数作为参数使用。

* ht：dict 的 ht 属性是有两个元素的数组，包含两个 dictht 哈希表。

  一般字典只使用`ht[0]`哈希表，`ht[1]`哈希表会在对`ht[0]`哈希表进行 rehash 的时候使用，即当哈希表的键值对数量超过负载数量过多的时候，会将键值对迁移到`ht[1]`上。

* rehashidx：记录着 rehash 的进度，如果目前没有在进行 rehash，它的值为 -1。

##### dictht (dict hash table)

* table：是一个数组，数组中的每个元素都是一个指向 dictEntry 结构的指针， 每个 dictEntry 结构保存着一个键值对。
* size：记录哈希表 table 的大小。
* used：记录哈希表目前已用节点的数量。
* sizemask：用于计算索引值，等于 size-1。

##### dictEntry

dictEntry 是哈希表节点，也就是我们存储数据地方。

* key：保存着键值对中的键。
* val：保存着键值对中的值，值可以是一个指针，也可以是整数或者浮点数。
* next：是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一次形成链表，以此来解决哈希冲突的问题。

#### 渐进式 rehash

Redis 的 rehash 动作并不是一次性完成的，而是分多次、渐进式地完成的，原因在于当哈希表里保存的键值对数量很大时， 一次性将这些键值对全部 rehash 可能会导致服务器在一段时间内停止服务，这个是无法接受的。

rehash 过程：

* 为 `ht[1]` 分配空间， 让字典同时持有 `ht[0]` 和 `ht[1]` 两个哈希表。

* 在字典中维持一个索引计数器变量 `rehashidx` ， 并将它的值设置为 0， 表示 rehash 工作正式开始。

* 将 `ht[0]` 哈希表在 `rehashidx` 索引上的所有键值对 rehash 到 `ht[1]` ， 当 rehash 工作完成之后， 程序将 `rehashidx` 属性的值增一。

  > 比如 rehashidx = 0，就将 table 中下标为 0 的元素全部 rehash 到 ht[1]，rehash 完成后将 rehashidx +1，然后 rehash table 中下标为 1 的元素，直到 ht[0] 变成空表。

* 随着字典操作的不断执行， 最终在某个时间点上， `ht[0]` 的所有键值对都会被 rehash 至 `ht[1]` ， 这时程序将 `rehashidx` 属性的值设为 -1， 表示 rehash 操作已完成。

因为在进行渐进式 rehash 的过程中， 字典会同时使用 `ht[0]` 和 `ht[1]` 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除 (delete)、查找 (find)、更新 (update) 等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 `ht[0]` 里面进行查找， 如果没找到的话， 就会继续到 `ht[1]` 里面进行查找。

另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 `ht[1]` 里面， 而 `ht[0]` 则不再进行任何添加操作： 这一措施保证了 `ht[0]` 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。

### 跳表 (SkipList)

#### 跳表结构

我们先来看一个有序链表，如下图 (最左侧的灰色节点表示一个空的头结点 ) ：

![img](/Users/licheng/Documents/Typora/Picture/659f5bec14ccd8d8c052.png)

在这样一个链表中，如果我们要查找某个数据，那么需要从头开始逐个进行比较，直到找到包含数据的那个节点，或者找到第一个比给定数据大的节点为止 (没找到 ) 。也就是说，时间复杂度为 $O(n)$。同样，当我们要插入新数据的时候，也要经历同样的查找过程，从而确定插入位置。

假如我们每相邻两个节点增加一个指针，让指针指向下下个节点，如下图：

![img](/Users/licheng/Documents/Typora/Picture/a9648d8a8d71023a630eee04a57e2116)

这样所有新增加的指针连成了一个新的链表，但它包含的节点个数只有原来的一半 (上图中是7, 19, 26 ) 。现在当我们想查找数据的时候，可以先沿着这个新链表进行查找。当碰到比待查数据大的节点时，再回到原来的链表中进行查找。比如，我们想查找23，查找的路径是沿着下图中标红的指针所指向的方向进行的：

![img](/Users/licheng/Documents/Typora/Picture/1b1a48631a5325f03821.png)

* 23首先和7比较，再和19比较，比它们都大，继续向后比较。
* 但23和26比较的时候，比26要小，因此回到下面的链表 (原链表 ) ，与22比较。
* 23比22要大，沿下面的指针继续向后和26比较。23比26小，说明待查数据23在原链表中不存在，而且它的插入位置应该在22和26之间。

在这个查找过程中，由于新增加的指针，我们不再需要与链表中每个节点逐个进行比较了。需要比较的节点数大概只有原来的一半。

利用同样的方式，我们可以在上层新产生的链表上，继续为每相邻的两个节点增加一个指针，从而产生第三层链表。如下图：

![img](/Users/licheng/Documents/Typora/Picture/d88e4d282ec5981c207c.png)

在这个新的三层链表结构上，如果我们还是查找23，那么沿着最上层链表首先要比较的是19，发现23比19大，接下来我们就知道只需要到19的后面去继续查找，从而一下子跳过了19前面的所有节点。可以想象，当链表足够长的时候，这种多层链表的查找方式能让我们跳过很多下层节点，大大加快查找的速度。

SkipList 插入节点时，每一个节点的层数 (level) 是随机出来的，而且新插入一个节点不会影响其它节点的层数。因此，插入操作只需要修改插入节点前后的指针，而不需要对很多节点都进行调整。这就降低了插入操作的复杂度。

> 层数随机算法：
>
> 1. 指定节点最大层数 MaxLevel，指定概率 p， 默认层数 lvl 为1。
> 2. 生成一个 0~1 的随机数 r，若 r<p，且 lvl < MaxLevel ，则 lvl ++。
> 3. 重复第 2 步，直至生成的 r >p 为止，此时的 lvl 就是要插入的层数。

#### 跳表的性质

跳跃表其实可以把它理解为多层的链表，它有如下的性质

* 多层的结构组成，每层是一个有序的链表。
* 最底层 (level 1) 的链表包含所有的元素。
* 跳表的查找次数近似于层数，时间复杂度为 $O(logn)$，插入、删除也为 $O(logn)$。
* 跳表是一种随机化的数据结构 (通过抛硬币来决定层数)。

#### 跳表的实现

<img src="/Users/licheng/Documents/Typora/Picture/image-20200715110727881.png" alt="image-20200715110727881" style="zoom:80%;" />

##### zskiplist

* header：表头结点。
* tail：表尾节点。
* length：表中节点的数量。
* level：表中层数最大的节点的层数。

##### zskiplistNode

* level 数组 (层)：每次创建一个新的跳表节点都会根据幂次定律计算出 level 数组的大小，也就是次层的高度，每一层带有两个属性——**前进指针**和**跨度**，前进指针用于访问表尾方向的其他指针；跨度用于记录当前节点与前进指针所指节点的距离 (如果指向的为 NULL，跨度为 0)。
* backward (后退指针)：指向当前节点的前一个节点。
* score：用来排序，如果 score 相同比较成员变量的字典序大小排序。
* obj 或 ele：成员对象是一个指针，指向一个字符串对象，里面保存着一个 SDS；在跳表中各个节点的成员对象必须唯一，分值可以相同。

#### SkipList 与平衡树、哈希表的比较

* SkipList 和各种平衡树 (如AVL、红黑树等 ) 的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个 key 的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。
* 在做范围查找的时候，平衡树比 SkipList 操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在 SkipList 上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。
* 平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而 SkipList 的插入和删除只需要修改相邻节点的指针，操作简单又快速。
* 从内存占用上来说，SkipList 比平衡树更灵活一些。一般来说，平衡树每个节点包含 2 个指针 (分别指向左右子树 ) ，而 SkipList 每个节点包含的指针数目平均为 1/(1-p)，具体取决于参数 p 的大小。如果像Redis 里的实现一样，取 p=1/4，那么平均每个节点包含 1.33 个指针，比平衡树更有优势。
* 查找单个 key，SkipList 和平衡树的时间复杂度都为 $O(logN)$，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近 O(1)，性能更高一些。所以我们平常使用的各种 Map 或dictionary 结构，大都是基于哈希表实现的。
* 从算法实现难度上来比较，SkipList 比平衡树要简单得多。
