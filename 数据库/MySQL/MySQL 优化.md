### 查询优化

查询很慢时，如果没有索引，可以考虑建一个索引；如果有索引，看看查询语句有没有走索引。

#### 定位查询语句

* 开启慢查询日志，通过慢查询日志定位那些执行效率较低的 SQL 语句。mysqld 写一个包含所有执行时间超过 long_query_time 秒 (默认 10 s) 的 SQL 语句的日志文件。

  开启：`set slow_query_log=1;`

* 可通过`show processlist` 来查看执行效率比较低的查询语句。


#### 分析查询语句

通过 Explain 对查询语句作分析。

##### id

select 查询的序列号，表示查询中执行 select 子句或操作表的顺序。

##### select_type

查询类型。

* SIMPLE：简单的 SELECT 查询，查询中不包含子查询或者 UNION。
* PRIMARY：查询中若包含子查询，最外层的查询标记为该标识。
* SUBQUERY：在 select 或 where 列表中包含的子查询标识。
* DERIVED：在 FROM 列表中包含的子查询标识。
* UNION：若第二个  select 出现在 UNION 之后，则标记为 UNION。
* UNION RESULT：从 UNION 表获取结果的 SELECT。

##### table

输出结果集的表。

##### type

访问类型。

* NULL：MySQL 不访问任何表、索引，直接返回结果。如查询系统时间。
* system：const 类型的特例，表中只有一行记录。
* const：表示通过索引一次就找到了，只返回一条数据。
* eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引。
* ref：非唯一性索引扫描，返回匹配某个单独值的所有行 (多个结果)。
* range：索引范围扫描，常见于 between，<，>，in 等操作。
* index：遍历索引树。
* all：遍历全表。

##### possible_keys

表示查询时，可能使用的索引。

##### key

表示查询时，实际用的索引。

##### key_len

索引字段的长度。

##### rows

扫描的行数。

##### extra

执行情况的说明和描述。

### 分库分表

#### 水平分表

* 概念：将字段按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。
* 适用场景：系统绝对并发量并没有上来，只是单表的数据量太多，影响了 SQL 效率，加重了 CPU 负担，以至于成为瓶颈。
* 拆分结果：表的数据量少了，单次SQL执行效率高，自然减轻了CPU的负担。

#### 垂直分表

* 概念：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。

* 适用场景：系统绝对并发量并没有上来，表的记录并不多，但是字段多，并且热点数据和非热点数据在一起，单行数据所需的存储空间较大。以至于数据库缓存的数据行减少，查询时会去读磁盘数据产生大量的随机读IO，产生IO瓶颈。

* 拆分结果：垂直分表的拆分原则是将热点数据放在一起作为主表，非热点数据放在一起作为扩展表。这样更多的热点数据就能被缓存下来，进而减少了随机读 IO。拆了之后，要想获得全部数据就需要关联两个表来取数据。

  > 千万别用join，因为 join 不仅会增加 CPU 负担并且会讲两个表耦合在一起（必须在一个数据库实例上）。关联数据，应该在业务Service层做文章，分别获取主表和扩展表数据然后用关联字段关联得到全部数据。

#### 水平分库

* 概念：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。
* 适用场景：系统绝对并发量上来了，并且可以抽象出单独的业务模块。
* 拆分结果：库多了，io和cpu的压力自然可以成倍缓解。

#### 垂直分库

* 概念：按照功能划分，把数据分别放到不同的数据库和服务器。
* 适用场景：系统绝对并发量上来了，分表难以根本上解决问题，并且还没有明显的业务归属来垂直分库。
* 拆分结果：到这一步，基本上就可以服务化了。例如，随着业务的发展一些公用的配置表、字典表等越来越多，这时可以将这些表拆到单独的库中，甚至可以服务化。再有，随着业务的发展孵化出了一套业务模式，这时可以将相关的表拆到单独的库中，甚至可以服务化。

#### 分库分表步骤

* 根据数据量评估分库或分表个数。

* 选 key (均匀)。

* 分表规则 (hash 或 range等)。

* 执行，双写或者升级从库。