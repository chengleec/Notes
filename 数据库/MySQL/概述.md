### 数据库范式

三大范式是一般设计数据库的基本理念，有助于可以建立冗余较小、结构合理的数据库。

#### 第一范式

确保每一列的原子性，即每个字段都是不可切分的最小单元，称 R 是满足第一范式的，简记为 1NF。

例：

<img src="/Users/licheng/Documents/Typora/Picture/image-20200914212435850.png" alt="image-20200914212435850" style="zoom: 50%;" />

* 插入异常：学生未选课，无法记录学生信息进数据库。
* 删除异常：删除所有学生成绩，就把课程信息全删除了。
* 更新异常：调整课程学分，所有行都调整。
* 数据冗余：每条记录都含有相同信息。

#### 第二范式

如果关系模式 R 满足第一范式，并且没有部分依赖于主键，称 R 满足第二范式，简记为 2NF。

例：

<img src="/Users/licheng/Documents/Typora/Picture/image-20200914212702823.png" alt="image-20200914212702823" style="zoom:50%;" />

* 数据冗余：有重复值。
* 更新异常：修改时需要同时修改多条记录，否则会出现数据不一致的情况 。

#### 第三范式

如果关系模式 R 满足第二范式，并且没有传递依赖，称 R 满足第三范式，简记为 3NF。

### 事务机制

一条或多条语句组成的一个执行单元，这个执行单元要么全部执行，要么全部不执行。

#### 事务 ACID 特性

* 原子性 Atomicity：指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
* 一致性 Consistency：事务执行结果必须使数据库从一个一致性状态变换到另一个一致性状态。
* 隔离性 Isolation：并发访问数据库时，一个事务不被其他事务所干扰，各并发事务之间数据库是独立的。
* 持久性 Durability：指一个事务一旦被提交，它对数据库中数据的改变是永久性的。

#### 并发事务带来的问题

* 脏读：对于两个事务 T1 和 T2，T1 读取了已被 T2 更新但还没有提交的字段，之后若 T2 回滚，T1 读取的内容是临时且无效的。 
* 不可重复读：T1 读取了一个字段，T2 更新该字段并提交 ，T1 再次读取同一字段，值不同。
* 幻读：T1 读的时候，读到一条记录，再读发现记录没有了，被其他事务删了。或者 T1 之前读的时候记录不存在，再读发现又有这条记录，其它事务增加了一条记录。

#### 事务隔离级别

* 读未提交：Read Uncommitted，允许其他事务读取未提交的数据。存在脏读、不可重复读、幻读。

* 读已提交：Read Committed，允许其他事务读取已经提交的事务。可以解决脏读问题，存在不可重复读、幻读。

* 可重复读：Repeatable Read，可以解决脏读，不可重复读问题，但存在幻读。默认的隔离级别。

* 可串行化：Serizable，事务一个接一个执行，后一个事务的执行必须等待前一个事务结束。解决所有并发问题，但效率较低。

  > 读取数据时加 S 锁，更新数据时加 X 锁。

##### 快照读

单纯的 select 操作，不加锁。不包括 `select ... lock in share mode`，`select ... for update`。　

读已提交每次执行 select 时都会生成一个快照，所以它重复读时数据可能不一致。

可重复读只有第一次执行 select 时会生成快照，并且之后的 select 都会使用第一次生成的快照。所以它解决了可重复读问题。

快照读使用 MVCC 实现：

innodb 在插入一条数据的时候会在后面跟上两个隐藏的列，一个保存了这个行的创建时系统版本号，一个保存的是行的删除的系统版本号。每开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的 ID。innodb 更新一条数据是设置旧数据删除版本号，然后插入一条新的数据并设置创建版本号，然后删除旧的数据。

##### 当前读

当前读，读取的是最新版本，并且对读取的记录加锁，阻塞其他事务同时改动相同记录，避免出现安全问题。

使用当前读的 SQL 语句：

* select...lock in share mode (共享读锁)
* select...for update
* update , delete , insert

当前读使用 next-key 锁 (行记录锁 + Gap 间隙锁) 实现：

* 对主键或唯一索引，where 条件全部精确命中 (=或者in)，只会加 Record Lock。

* 非唯一索引列，如果 where 条件部分命中 (>、<、like等) 或者全未命中，则加间隙锁。
* 对于没有索引的列，会对全表加间隙锁。

> Record Lock：加在索引上，锁住一条记录。有两种类型：S 锁和 X 锁。
>
> Gap Lock：锁住一个范围，主要用于防止 insert，解决幻读问题。只有 S 锁。
>
> Next-key Lock：Record Lock + Gap Lock，既锁住记录本身，又锁范围。属性由 Record Lock 确定。

#### 事务日志

##### redo log (WAL)

由 InnoDB 引擎实现，是物理日志，记录的是物理数据页修改的信息，比如"某个数据页上内容发生了哪些改动"。

当一条数据需要更新时，InnoDB 会先将更新操作记录到 redo log 中，然后更新数据。InnoDB 引擎会在 MySQL 空闲时将 redo log 刷新到磁盘中。

redo log 是顺序写入指定大小的物理文件中的。当文件快写满时，会从头开始边擦除边刷盘。

redo log 可以实现崩溃恢复，保证事务的持久性。

##### undo log

由 InnoDB 引擎实现，是逻辑日志，记录数据修改被修改前的值。比如把 `Name='B'` 修改为 `Name = 'B2'` ，那么 undo log 就会存放`Name='B'` 的记录。

当一条数据需要更新前，会先把修改前的记录存储在 undo log 中。如果这个修改出现异常，则会使用 undo log 来实现回滚操作，保证事务的原子性。

当事务提交之后，undo log 并不能立马被删除，而是会被放到待清理链表中，待判断没有事物用到该版本的信息时才可以清理相应 undo log。

保存了事务发生之前的数据的一个版本，用于回滚，同时可以提供多版本并发控制下的读 (MVCC)。

##### bin log

由 Mysql 的 Server 层实现，是逻辑日志，记录了对 MySQL 数据库执行更改的所有操作。

innodb 中存储引擎会为每个事务分配一个默认大小为 32K 的缓冲区，事务在提交之前会把二进制日志写入缓冲区中，等事务提交时再将缓冲区中的日志追加到文件中，当前文件写满则会创建新的文件写入。

binlog 主要用于主从复制和数据库恢复。

binlog 有 3 中格式：

* statement：每一条会修改数据的 sql 语句都会记录在 binlog 中。
* row：仅保存哪条记录被修改。
* mix：一般的语句修改使用 statment 格式保存 binlog，如一些函数，statement 无法完成主从复制的操作，则采用 row 格式保存 binlog。

### SQL 语句执行过程

* 先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。

* 解析器解析 SQL 语句，生成对应的解析树。

* 查询优化器确定执行计划。

  > 比如 `select * from student  A where A.age='18' and A.name='张三';`，要确定先查张三，再找 18 岁；还是先找 18 岁的人，再找张三。

### InnoDB 与 MyISAM

* MyISAM 只支持表级锁，而 InnoDB 支持行级锁和表级锁，默认为行级锁。
* InnoDB 支持一些高级功能：外键、事务、崩溃后的安全恢复 (redo log)；MyISAM 都不支持。

#### 适用场景

* 如果要求事务或者有大量的 Insert 和 Update 操作，应该选用 InnoDB，因为 MyISAM 的表锁粒度太大，InnoDB 的行锁可以提高并发度。
* 如果不要求事务并且 Select 操作比较多，那么就选用 MyISAM，因为 InnoDB 检查和维护的东西要比 MyISAM 多，比如 MVCC。

### 主从复制

主从复制是指一台服务器充当主服务器，负责写数据。另一台或多台服务器充当从服务器，负责读数据，从而提高数据库的可用性。

#### 主从复制过程

主库会将数据变化写入 binlog 日志，从库连接到主库之后，主库会创建一个 binlog dump 线程，用于发送 binlog 的内容；从库有一个 IO 线程负责将主库的 binlog 日志拷贝到自己本地的 relay log (中继日志) 中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，最终保证主从数据的一致性。

#### 主从同步延迟

主库多线程写入频繁，从库只有一个 SQL 线程跟不上。(提升从库的硬件设备，如 SSD)，而且现在也支持多线程复制了。

主库有大事务，执行时间长。（优化业务，将大事务拆分成小事务）