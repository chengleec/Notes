### 概述

索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有：B树， B+ 树和 Hash。

#### 创建索引

```mysql
# 主键索引
ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` )
# 唯一索引
ALTER TABLE `table_name` ADD UNIQUE ( `column` )
# 普通索引
ALTER TABLE `table_name` ADD INDEX index_name ( `column` ) /* 一列 */
ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` ) /* 多列 */
# 全文索引
ALTER TABLE `table_name` ADD FULLTEXT ( `column` )

CREATE [UNIQUE | FULLTEXT ]  INDEX index_name ON 'table_name'('column')
```

#### 优点

* 可以加快数据的检索速度。

* 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
* 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

* 在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。

#### 缺点

* 创建索引和维护索引要耗费时间，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

* 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。

#### 索引类型

* 主键索引：数据表的主键列使用的就是主键索引。

* 普通索引 (Index) ：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。

* 唯一索引 (Unique Key) ：唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。

  > 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。

* 前缀索引(Prefix) ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符。

* 全文索引(Full Text) ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。

#### 索引设计原则

* 对查询频次较高，数据量比较大的表建立索引

* 选择`WHERE`子句中频繁使用的字段建立索引

* 尽可能使用唯一索引，重复值越少，索引效果越强

* 限制索引的数量。索引越多，占用空间越大，维护代价越高，性能反而越慢

* 充分利用最左前缀原则，N 个列组成的复合索引，如果使用得当，相当于创建了 N 个索引。

  > 经常更新的字段不适合创建索引

#### 索引失效情况

* 最左前缀法则：如果索引了多列，要遵守最左前缀法则。
* 在索引上进行运算操作，会造成索引失效。
* like 模糊查询以 % 开头的，索引会失效（仅仅尾部模糊匹配，索引不会失效）。
* `in`走索引，`not in`不走索引。
* 范围查询列右边的列，不会使用索引，`where id > "1" and name = "lc"`
* 条件中有 or，如果 or 前的条件中的列有索引，但后面的列没有索引，那么涉及的索引都会失效。
* 字符串不加单引号，会造成索引失效。

**为什么要遵守最左前缀匹配原则？**

索引的底层是一颗 B+ 树，那么联合索引的底层也就是一颗 B+ 树，只不过联合索引的 B+ 树节点中存储的是键值。由于构建一棵 B+ 树只能根据一个值来确定索引关系，所以数据库依赖联合索引最左的字段来构建。

<img src="/Users/licheng/Documents/Typora/Picture/image-20200715211832232.png" alt="image-20200715211832232" style="zoom:50%;" />

(a,b) 可以看到 a 的值是有顺序的，而 b 的值是没有顺序的。但是我们又可发现 a 在等值的情况下，b 值又是按顺序排列的，但是这种顺序是相对的。这是因为 MySQL 创建联合索引的规则是首先会对联合索引的最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序。所以 b=2 这种查询条件没有办法利用索引。

### 索引底层实现原理

#### 数据结构选择

* 哈希表： 对于等值查询，Hash索引具有明显的优势，只需要 O(1) 的时间复杂度就可以找到相应的数据。但Hash 索引不支持顺序和范围查询，所以不适合作为 MySQL 索引的底层数据结构。

* 二叉查找树：BST 的查找平均时间复杂度为 O(log~2~n)，而且支持范围查询。但极端情况下会退化为线性链表，时间复杂度退化为 O(n)，检索速度大大降低。

* 二叉平衡树：AVL 树的平均查找性能为 O(log~2~n)，不存在极端情况下的低效查找情况，也可以实现范围查找，数据有序。但每一个树节点只能存储一个数据，磁盘 IO 会成为查询数据的瓶颈。

* B 树：多路平衡查找树，B 树中所有结点的孩子个数的最大值称为 B 树的阶。一棵 m 阶 B 树有如下性质：

  * 树中每个结点至多有 m 棵子树， 关键字个数最多有 m-1 个。

  * 非叶根节点至少有两棵子树，其他非叶结点至少有 $\lceil m / 2 \rceil$ 棵子树。
  * 所有的叶结点都出现在同一层次上，并且不带任何信息。

* B+ 树：B 树的变体，一棵 m 阶 B 树有如下性质：
  * 每个非叶结点最多有 m 棵子树，子树个数与关键字个数相等。
  * 非叶根结点至少有两棵子树，其他非叶节点至少有 $\lceil m / 2 \rceil$ 棵子树。
  * 非叶节点只保存索引，不保存数据。
  * 所有叶结点包含全部关键字信息，叶结点中将关键字按大小顺序排列，并且相邻叶结点按大小顺序相互链接起来。

##### B 树与 B+ 树的区别

* B 树非叶节点里存的是数据，B+ 树非叶节点存储的是索引（地址），B+ 树所有的数据都存储在叶子节点中。在单个节点存储容量有限的情况下，B+ 树的高度会更低，减少了磁盘 IO 次数。

  > 数据占空间更大，所以存储的数量有限，索引占空间小，所以 B+ 树每个节点可以存储更多的索引，使 B+ 树更加扁平。

* B 树的叶子节点都是独立的，B+ 树的叶子节点有一条引用链指向与它相邻的叶子节点，便于顺序查找和范围查找。

* B+ 树的检索效率比较稳定，任何查找都是从根节点到叶子节点的过程。

**磁盘预读原理**：将一个节点的大小设为等于一个页，这样每个节点只需要一次 I/O 就可以完全载入。

#### 存储引擎底层实现

##### MyISAM

MyISAM 创建表后生成的文件有：

* .frm：建表语句
* .MYD（MyISAM Data）：表中的数据文件
* .MYI（MyISAM Index）：表中的索引文件

![image-20200429093108462](/Users/licheng/Documents/Typora/Picture/image-20200429093108462.png)

MyISAM 用的是非聚集索引方式，即数据和索引落在不同的两个文件上。MyISAM 在建表时以主键作为 KEY 来建立主索引 B+树，树的叶子节点存的是对应数据的物理地址。我们拿到这个物理地址后，就可以到 MyISAM 数据文件中直接定位到具体的数据记录了。

##### InnoDB

InnoDB 创建表后生成的文件有：

* .frm：建表语句
* .idb：表数据 + 索引文件

![image-20200429093047698](/Users/licheng/Documents/Typora/Picture/image-20200429093047698.png)

InnoDB 是聚集索引方式，因此数据和索引都存储在同一个文件里。首先 InnoDB 会根据主键 ID 作为 KEY 建立索引 B+ 树，而 B+ 树的叶子节点存储的是主键 ID 对应的数据。

**回表查询**：先通过普通索引定位到主键 key，然后通过主键索引定位行记录。

**覆盖索引**：如果 where 条件的列和要查询的字段在一个索引中，那么不需要回表查询，那么就叫覆盖索引。常见方法是将被查询的字段建立到联合索引里去。

> MyISAM 的二级索引查询效率比 InnoDB 的二级索引查询效率更高，因为 MyISAM 可以直接到数据文件中查询数据，InnoDB 要到主键索引中再查一次表。

### 聚集索引和非聚集索引

#### 聚集索引

聚集索引即索引结构和数据一起存放的索引。索引项的顺序与表中记录的物理顺序一致。

> InnoDB 的主键索引属于聚集索引

优点：查询速度快。因为叶子节点有序，定位到索引的节点，就相当于定位到了数据。而且只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放

缺点：更新代价大 。为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序。

#### 非聚集索引

非聚集索引即索引结构和数据分开存放的索引， 表数据存储顺序与索引顺序无关。

优点：更新代价比聚集索引要小。

缺点：可能需要二次查询，当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。