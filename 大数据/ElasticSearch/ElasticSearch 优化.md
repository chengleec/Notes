#### FileSystem Cache

往 ES 里写的数据，实际上都写到磁盘文件里去了，**查询的时候**，操作系统会将磁盘文件里的数据自动缓存到 FileSystem cache 里面去。如果给 FileSystem Cache 更多的内存，尽量让内存可以容纳所有的 `idx segment file `索引数据文件，那么搜索的时候就基本都是走内存的，性能会非常高。(FileSystem Cache 在逻辑上属于磁盘，但实际上基于性能的考虑被保存在内存中)。

尽量减少单条数据的数据量，因为单条数据的数据量越大，就会导致 FileSystem Cahce 能缓存的数据就越少。可以把主要用来检索的少数几个字段写入 ES 中就可以了，然后你可以把其他的字段数据存在 MySQL/HBase 里，可以使用 `ES + HBase` 这么一个架构。根据检索字段从 ES 中获取文档 id，然后根据文档 id 去 HBase 中查询完整的数据。

写入 ES 的数据最好小于等于，或者是略微大于 ES 的 FileSystem Cache 的内存容量。然后你从 ES 检索可能就花费 20ms，然后再根据 ES 返回的 id 去 HBase 里查询，查 20 条数据，可能也就耗费个 30ms，可能你原来那么玩儿，1T 数据都放 ES，会每次查询都是 5~10s，现在可能性能就会很高，每次查询就是 50ms。

### 数据预热

假如说，哪怕是你就按照上述的方案去做了，es 集群中每个机器写入的数据量还是超过了 `filesystem cache` 一倍，比如说你写入一台机器 60G 数据，结果 `filesystem cache` 就 30G，还是有 30G 数据留在了磁盘上。

其实可以做**数据预热**。

举个例子，拿微博来说，你可以把一些大V，平时看的人很多的数据，你自己提前后台搞个系统，每隔一会儿，自己的后台系统去搜索一下热数据，刷到 `filesystem cache` 里去，后面用户实际上来看这个热数据的时候，他们就是直接从内存里搜索了，很快。

或者是电商，你可以将平时查看最多的一些商品，比如说 iphone 8，热数据提前后台搞个程序，每隔 1 分钟自己主动访问一次，刷到 `filesystem cache` 里去。

对于那些你觉得比较热的、经常会有人访问的数据，最好**做一个专门的缓存预热子系统**，就是对热数据每隔一段时间，就提前访问一下，让数据进入 `filesystem cache` 里面去。这样下次别人访问的时候，性能一定会好很多。

### 冷热分离

ES 可以做类似于 MySQL 的水平拆分，就是说将大量的访问很少、频率很低的数据，单独写一个索引，然后将访问很频繁的热数据单独写一个索引。最好是将**冷数据写入一个索引中，然后热数据写入另外一个索引中**，这样可以确保热数据在被预热之后，尽量都让他们留在 `filesystem os cache` 里，别让冷数据给冲刷掉。

#### 插入索引自动生成 id

当写入端使用特定的 id 将数据写入 ES 时，ES 会检查对应的索引下是否存在相同的 id，这个操作会随着文档数量的增加使消耗越来越大，所以如果业务上没有硬性需求建议使用 ES 自动生成的 id，加快写入速率。