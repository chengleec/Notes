### Zookeeper 特点

Zookeeper 将数据全量存储在内存中，以此来实现高吞吐，减少访问延迟。

* 顺序一致性：从一个客户端发起的事务请求，最终都会严格按照其发起顺序被应用到 Zookeeper 中。
* 原子性：所有事务请求的处理结果在整个集群中所有机器上都是一致的。
* 单一系统镜像：所有客户端看到的服务端数据模型都是一致的。
* 可靠性：一旦服务端成功应用了一个事务，则其引起的改变会一直保留，直到被另外一个事务所更改；
* 实时性：一旦一个事务被成功应用后，Zookeeper 可以保证客户端立即可以读取到这个事务变更后的最新状态的数据。

### Zookeeper 系统模型

#### 数据模型

Zookeeper 通过树形结构来存储数据，它由一系列被称为 ZNode 的数据节点组成。ZNode 是 zookeeper 中的最小数据单元，每个 ZNode 上都可以保存数据，同时还可以挂载子节点，形成一个树形化命名空间。**Zookeeper 将数据全量存储在内存中，以此来实现高吞吐，减少访问延迟。**

<img src="/Users/licheng/Documents/Typora/Picture/image-20200501150804664.png" alt="image-20200501150804664" style="zoom:67%;" />

* ZNode 结点类型
  * 持久节点：一旦创建就一直存在，直到将其删除。
  * 持久顺序节点：一个父节点可以为其子节点维护一个创建的先后顺序 ，这个顺序体现在节点名称上，是节点名称后自动添加一个由 10 位数字组成的数字串，从 0 开始计数。
  * 临时节点：临时节点的生命周期是与客户端会话绑定的，会话消失则节点消失 。临时节点只能做叶子节点 ，不能创建子节点。
  * 临时顺序节点：父节点可以创建一个维持了顺序的临时节点 (和前面的持久顺序性节点一样)。

* ZNode 结点状态：每个 ZNode 节点在存储数据的同时，都会维护一个叫做 Stat 的数据结构，里面存储了关于该节点的全部状态信息。
  * czxid：Created ZXID，该数据节点被创建时的事务ID。
  * mzxid：Modified ZXID，节点最后一次被更新时的事务ID。
  * ctime：Created Time，该节点被创建的时间。
  * mtime： Modified Time，该节点最后一次被修改的时间。
  * version：节点的版本号。
  * cversion：子节点的版本号。
  * aversion：节点的ACL版本号。
  * ephemeralOwner：创建该节点的会话的 sessionID ，如果该节点为持久节点，该值为0。
  * dataLength：节点数据内容的长度。
  * numChildre：该节点的子节点个数，如果为临时节点为0。
  * pzxid：该节点子节点列表最后一次被修改时的事务ID，注意是子节点的列表 ，不是内容。

#### 会话

Zookeeper 客户端通过 TCP 长连接连接到服务集群，会话 (Session) 从第一次连接开始就已经建立，之后通过心跳检测机制来保持有效的会话状态。通过这个连接，客户端可以发送请求并接收响应，同时也可以接收到 Watcher 事件的通知。

关于会话中另外一个核心的概念是 sessionTimeOut (会话超时时间)，当由于网络故障或者客户端主动断开等原因，导致连接断开，此时只要在会话超时时间之内重新建立连接，则之前创建的会话依然有效。

#### Watcher机制

Zookeeper 中一个常用的功能是 Watcher（事件监听器），客户端向服务端注册指定的 watcher ，当服务端符合了 watcher 的某些事件或要求则会向客户端发送事件通知 ，客户端收到通知后找到自己定义的 Watcher 然后执行相应的回调方法 。

#### ACL

Zookeeper 采用 ACL（Access Control Lists）策略来进行权限控制，它定义了如下五种权限：

* CREATE ：创建子节点的权限。
* READ：获取节点数据和子节点列表的权限。
* WRITE：更新节点数据的权限。
* DELETE：删除子节点的权限。
* ADMIN：设置节点 ACL 的权限。

### ZAB协议

* Leader ：集群唯一的写请求处理者 ，能够发起投票（投票也是为了进行写请求）。
* Follower：能够接收客户端的请求，如果是读请求则可以自己处理，如果是写请求则要转发给 Leader 。在选举过程中会参与投票，有选举权和被选举权 。
* Observer ：就是没有选举权和被选举权的 Follower 。

#### 消息广播 (2PC)

* leader 服务器将每个事务请求生成对应的 Proposal，并为这个 Proposal 分配一个全局单调递增且唯一的 id。

  > **zxid**，64 位，前 32 位是  epoch，每次 leader 改变后都会变，后 32 位为单调递增的计数器，表示事务 id。

* leader 服务器与每个 follower 之间都有一个队列，leader 将消息发送到该队列，将 Proposal 广播给所有的 follower 服务器。

* follower 服务器以事务日志的形式写入磁盘，成功写入后会反馈给 leader 服务器一个 ack 响应，当 leader 服务器接收到超过半数的 ack 以后，开始广播 commit 消息，同时 leader 服务器自身完成对事务的提交，每一个 follower 服务器收到 commit 消息后也完成对事务的提交。

#### 崩溃恢复

当集群中有机器挂了，整个集群如何保证数据一致性问题。

* 当服务器初始化时，或者 leader 服务器出现故障，整个系统会首先进行 leader 选举。
  1. 第一阶段每个机器都会投票给自己，投票内容包括 zxid 和 sid。
  2. 第二阶段机器之间互相投票，并将别人的选票与自己的选票进行比较，首先它会比较 zxid ，如果别人的 zxid 大于自己的，就变更为更大 zxid 的选票，如果相等再比较 sid。
  3. 然后将选票内容广播出去，如果一台机器收到了超过了半数相同的投票，则该投票对应的 sid 服务器称为 leader。

* 确保已经被 leader 提交的提案最终能够被所有的 follower 提交。

  如果 leader 只给部分 follower 发送 commit 请求后就挂掉了，造成一部分 follower 执行了 commit，一部分follower 没有执行 commit，导致数据不一致。（选举时会比较 zxid，确保新的 leader 执行了最新事务）。

* 确保丢弃已经被 leader 提出但未提交的提案。

  如果 leader 还没有发送出去 commit 请求就挂掉了，当重新连接集群变成 follower 后，必须将未提交的提案丢弃。

* 数据同步。

  leader 会将自身提交的最大 proposal 对应的 zxid 发送给其他 follower 结点，follower 根据 leader 的消息进行回退或者数据同步操作，保证集群所有节点的数据副本保持一致。

### 典型应用场景

* 数据订阅/发布

  利用 Watcher 特性，采用推拉结合的模式，客户端向服务端注册自己要关注的节点，一旦节点发生数据变更，服务器就会向客户端发送事件通知 。

* 集群管理

  利用 Zookeeper 的 Watcher 和临时节点特性，监控机器的上下线以及运行状态。

* Master 选举

  利用 Zookeeper 的强一致性、Watcher 特性，集群客户端同时向 Zookeeper 某个节点下创建临时节点，只有唯一一个客户端能够创建成功，成功的则为 Master，其他客户端将在这个节点上注册 Watcher，一旦原本的Master 挂了，则得到事件通知，重新进行 Master 选举。

* 命名服务

  利用顺序子节点的特性，为客户端提供唯一的命名 id。

* 分布式锁
  利用临时顺序子节点来实现，所有客户端在某个节点下创建临时顺序子节点，并在名称上标注读写。

  * 共享锁：如果没有比自己更小的节点，或比自己小的节点都是读请求 ，则可以获取到读锁，然后就可以开始读了。
  * 排它锁：如果没有比自己更小的节点 ，则表示当前客户端可以直接获取到写锁，对数据进行修改。若发现有比自己更小的节点，无论是读操作还是写操作，当前客户端都无法获取到写锁 ，等待所有前面的操作完成。
  * 互斥锁：因为创建节点的唯一性，我们可以让多个客户端同时创建一个临时节点，创建成功的就说明获取到了锁 。然后没有获取到锁的客户端创建一个 watcher 进行节点状态的监听，如果这个互斥锁被释放了，可以调用回调函数重新获得锁。

### Zookeeper-Shell
| 命令                                        | 描述                                 |
| ------------------------------------------- | ------------------------------------ |
| `ls /`                                      | 显示节点列表                         |
| `ls -s /`                                   | 显示节点列表并显示节点信息           |
| `create [-s] [-e] path data acl`            | 创建节点，-s为有序节点，-e为临时节点 |
| `get path`  /  `stat path`                  | 查看节点状态                         |
| `set path data [version]`                   | 更新节点，但版本号不一致时会拒绝修改 |
| `delete path [version]`  / `deleteall path` | 删除节点                             |