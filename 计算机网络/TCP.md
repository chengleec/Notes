### TCP 报文段

<img src="/Users/licheng/Documents/Typora/Picture/image-20200603152157079.png" alt="image-20200603152157079" style="zoom:80%;" />

* 源端口：发送端套接字的端口号
* 目的端口：接收端套接字端口号
* 序号：数据报第一个数据字节的序列号，用作标识该报文段序列号。
* 确认号：接收方期望从对方接受的字节编号。是对已收到报文的一个确认。
* TCP 首部长度：标明 TCP 协议报头长度，单位为 4 个字节，其最小值为 5，最大值为 15（所以首部长度最小值为 $5\times4=20B$，最大值为 $15\times4=60B$。
* 标志位：
  * URG（Urgent）：紧急指针有效性标志。
  * 客户端CK（客户端cknowledgment）：确认序号有效性标志，一旦一个连接建立起来，该标志总被置为 1。
  * PSH（Push）：接收方应尽快将报文段提交至应用层。
  * RST（Reset）：当 TCP 连接出现异常时重置连接的标志。
  * SYN（Synchronization）：建立连接时让连接双方同步序列号。
  * FIN（Finish）：释放连接时使用。
* 窗口：表示接收方还可以接受数据大小。
* 效验和：效验和覆盖整个 TCP 报文段，强制字段，由发送端计算存储，接收端进行验证。
* 紧急指针：当 Urgent 标志置 1 时，紧急指针才有效。

### TCP 连接

#### 建立连接 

##### 连接过程（三次握手）

<img src="/Users/licheng/Documents/Typora/Picture/image-20200617134936000.png" alt="image-20200617134936000" style="zoom:67%;" />

1. 客户端首先向服务器发送一个连接请求报文段。SYN 标志位被置为 1，起始序号会选择一个随机值 x，不携带数据。客户端进入SYN_SEND 状态。
2. 服务器收到连接请求报文段后，如同意建立连接，就返回连接确认报文段。SYN 和 ACK 标志位都被置为 1，起始序号会选择一个随机值 y，确认号字段为 x + 1，不携带数据。服务器进入 SYN_RCVD 状态。
3. 客户端收到连接确认报文段后，还要向服务器发送确认报文段。ACK 标志位被置为 1，序号为 x + 1，确认号为 y + 1。该报文段可以携带数据，如果不携带数据，则不消耗序号。

##### 为什么要三次握手？两次不可以吗？

只成功完成两次握手的时候，服务器不知道自己的发送能力是否正常，也不知道客户端的收报能力是否正常，所以它们需要第三次握手。

同时，如果没有第三次连接，服务器可能会建立一个脏连接。已失效的请求报文又传送到了服务端，建立了多余的链接，浪费资源。

##### 第一次握手为什么不能携带数据？

如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。

##### 为什么 TCP 采用随机初始序列号？

这样做主要是出于网络安全的因素着想。如果不是随机产生初始序列号，其他人可能会猜到你与其他主机之间通信的序列号，那么可以伪造这个序列号进行攻击。

##### 半连接队列

服务器第一次收到客户端的连接请求之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。

全连接队列就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

##### SYN 攻击

SYN 攻击是指客户端在短时间内使用大量不存在的 IP 地址向服务器不断地发送连接请求，服务器会将连接请求放入半连接队列中，但由于源地址不存在，因此服务器需要不断重发确认报文，这些伪造的连接请求将长时间占用半连接队列，导致正常的连接请求因为队列满而被丢弃。

**检测 SYN 攻击**

`netstat -n -p TCP | grep SYN_RECV`

**解决方法：SYN Cookie**

当服务器遭受 SYN 攻击使得半连接队列满时，服务器并不拒绝新的连接请求，而是将 Cookie 作为连接确认报文的初始序列号发送给客户端，Cookie 是通过对客户端的 IP 地址、端口号，服务器的 IP 地址、端口号等一些其他元素加密运算得到的一个初始序列号。如果收到客户端的确认报文，服务器它的确认号字段减去 1 与之前的 Cookie 作比较。如果相等，直接完成三次握手，就不用半连接队列了。

#### 释放连接

##### 释放过程（四次挥手）

<img src="/Users/licheng/Documents/Typora/Picture/image-20200617135947988.png" alt="image-20200617135947988" style="zoom:67%;" />

1. 客户端关闭连接时，会发送一个连接释放报文段。FIN 标志位被置为 1，序号为 u，即已发送数据的最后一个字节的序号加 1，不携带数据。客户端进入 FIN_WAIT1 状态。

2. 服务器收到连接释放报文段后会返回确认报文段，ACK 标志位置为 1，序号是已发送数据的最后一个字节的序号加 1，确认号是 u + 1。服务器进入 CLOSE_WAIT 状态，客户端收到服务器的确认后，进入FIN_WAIT2 状态。此时 TCP 处于半关闭状态，客户端到服务端的连接释放。

3. 如果服务器已经没有数据发送，就发送一个连接释放报文段。FIN 和 ACK 标志位都被置为 1， 序号为 w，即已发送数据的最后一个字节的序号加 1，确认号为 u + 1。服务器进入 LAST_ACK 状态，等待客户端返回最终的确认。

4. 客户端收到连接释放报文段后，会返回一个确认报文段。ACK 被置为 1，序号为 u + 1，确认号为 w + 1。客户端进入 TIME_WAIT 状态，等待 2MSL 之后关闭连接，进入 CLOSE 状态。服务器收到客户端的确认报文段后，会直接进入 CLOSE 状态。

   > MSL 时间不一定，可能是 30s、也可能是 1分钟、2 分钟，必须要大于 TTL。

##### TIME_WAIT

**为什么需要 TIME_WAIT 状态**

* 确保最后一个确认报文能够到达，如果服务器没收到客户端发送的确认报文，那么就会重新发送连接释放请求报文。客户端需要重新确认。
* 让本连接产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

**大量 TIME_WAIT 造成的影响**

如果客户端的并发量很高，并且业务处理 + 传输数据的时间远远小于 TIME_WAIT，会出现大量 Socket 处于 TIME_WAIT 状态，会占用大量端口，此时部分客户端就会显示连接不上。

**如何处理 TIMEWAIT 过多**

打开系统的 TIME_WAIT 重用和快速回收。

### TCP 的粘包现象和处理方法

TCP 粘包是指发送方发送的多个数据包，到接收方后前后粘连到了一起。

#### TCP 粘包原因分析

##### 发送方

TCP 协议默认采用 Nagle 算法，它会合并相连的小数据包，再一次性发送，以达到提升网络传输效率的目的。

##### 接收方

如果 TCP 接收分组的速度大于应用程序读分组的速度，可能会造成接收缓存中的多个包粘连在一起。

#### 如何处理粘包现象？

##### 禁用 Nagle 算法

因为 TCP 协议采用 Negle 算法导致的粘包。所以可以禁用 Nagle 算法。

这种方法虽然能一定程度上解决 TCP 粘包，但是并不能完全解决问题。因为接收方也是可能造成粘包的原因，这种方法只是发送方有效。而且禁用 Nagle 算法，一定程度上使 TCP 传输效率降低了。所以，这并不是一种理想的方法。

##### 格式化数据

每条数据有固定的开始符和结束符。这种方法简单易行，但选择开始符和结束符的时候一定要注意每条数据的内部一定不能出现开始符或结束符。

##### 指定发送长度

发送每条数据的时候，将数据的长度一并发送，比如可以选择每条数据的前 4 位是数据的长度，应用层处理时可以根据长度来判断每条数据的开始和结束。

### 滑动窗口协议

#### 停止-等待协议

当发送窗口和接收窗口的大小固定为 1 时，滑动窗口协议退化为停等协议。该协议规定发送方每发送一帧后就要停下来，等待接收方确认后才能继续发送下一帧。

由于接收方需要判断接收到的帧是新发的帧还是重新发送的帧，因此发送方要为每一个帧加一个序号。由于停等协议规定只有一帧完全发送成功后才能发送新的帧，因而只用一比特来编号就够了，具有累计确认机制。

#### 回退N帧协议

发送窗口大于 1，接收窗口大于 1， 由于停等协议要为每一个帧进行确认后才继续发送下一帧，大大降低了信道利用率，因此又提出了后退 N 帧协议。

后退 N 帧协议中，发送方在发完一个数据帧后，不停下来等待应答帧，而是连续发送若干个数据帧。但发送方在每发送完一个数据帧时都要设置超时定时器。当超时后仍未收到确认帧，就要重发丢失的数据帧之后的所有数据。

#### 选择重传协议

发送窗口大于 1，接收窗口大于 1。在后退 N 帧协议中，接收方若发现错误帧就不再接收后续的帧，这显然是一种浪费。

选择重传协议是当接收方发现某帧出错后，其后继续送来的正确的帧存放在接收缓冲区中，同时要求发送方重新发送出错的那一帧。一旦收到重新传来的帧后，就可以原已存于缓冲区中的其余帧一并按正确的顺序递交高层。

### 重传机制

#### 超时重传

TCP 每发送一个报文段，就对这个报文段设置一次计时器。计时器设置的重传时间到期但还未收到确认时，就要重传这一报文段。

#### 快速重传

快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。

### 流量控制

TCP 提供一种机制可以让发送方根据接收方的实际接收能力控制发送的数据量，这就是所谓的流量控制。

接收方根据自已接收缓存的大小，动态地调整发送方的发送窗口大小，即调整 TCP 报文段首部中的＂窗口” 字段值，来限制发送方发送报文的速率。

### 拥塞控制

拥塞控制，是指防止过多的数据进入网络中，造成网络拥塞。

为了防止拥塞窗口增长过大引起网络拥塞，设置一个慢开始门限（ ssthresh 状态变量）

* 当拥塞窗口＜ ssthresh，使用慢开始算法（指数增长）
* 当拥塞窗口＞= ssthresh，使用拥塞避免算法

![](/Users/licheng/Documents/Typora/Picture/image-20200617152313008.png)

#### 慢开始

开始时令拥塞窗口 cwnd = 1，即一个最大报文段长度 MSS。每收到**一个 ack**的确认后，将窗口值加 1, 即增大一个 MSS (收到多个 ack， 就会增大多个 MSS)。这样每经过一个传输轮次 (即往返时延 RTT)，拥塞窗口就会加倍。当增大到一个规定的慢开始门限，改用拥塞避免算法。

#### 拥塞避免

发送端的拥塞窗口 cwnd 每经过一个往返时延 RTT 就加 1，而不是加倍。当出现一次超时时，令慢开始门限等于当前拥塞窗口的一半。

网络出现拥塞时 ，无论是在慢开始阶段还是在拥塞避免阶段，只要发送方检测到超时事件，就要把慢开始门限设置为出现拥塞时的发送方的拥塞窗口值的一半 (但不能小于 2)。然后把拥塞窗口 cwnd 重新设置为 1，执行慢开始算法。 这样做的目的是迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把积压的分组处理完。

#### 快速恢复

发送端收到连续三个冗余 ACK 时，把慢开始门限设置为出现拥塞时发送方 cwnd 的一半。把 cwnd 的值也设置为之前的一半， 然后开始执行拥塞避免算法。

******

发送方在确定发送报文段的速率时， 既要根据接收方的接收能力，又要从全局考虑不要使网络发生拥塞。 因此，TCP协议要求发送方维护以下两个窗口：

* 接收窗口 rwnd：接收方根据目前接收缓存大小所许诺的最新窗口值，反映接收方的容量。由接收方根据其放在TCP 报文的首部的窗口字段通知发送方。
* 拥塞窗口 cwnd：发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络的当前容量。 只要网络未出现拥塞， 拥塞窗口就再增大一些，以便把更多的分组发送出去。 但只要网络出现拥塞， 拥塞窗口就减小一些，以减少注入网络的分组数。

### TCP 如何保证数据可靠性

三次握手、四次挥手、校验和、序列号和确认号机制、超时重传、流量控制、拥塞控制。

### TCP 与 UDP

#### 区别

* TCP 是面向连接的，提供可靠服务。UDP 是无连接的，不提供可靠服务。
* TCP 面向字节流 (因为有连接)，UDP 面向报文段。
* TCP 传输效率慢，需要资源多。UDP 传输效率快，需要资源少。
* TCP 首部有 20 ~ 60 个字节，UDP 首部由 8 个字节 4 个字段组成。

#### 协议

| 基于 TCP | 功能                                                         |
| -------- | ------------------------------------------------------------ |
| FTP      | 文件传输协议，使用 21 端口。                                 |
| SMTP     | 邮件传送协议，用于发送邮件。服务器开放的是 25 号端口。       |
| POP3     | POP3 用于接收邮件。POP3 协议所用的是 110 端口。              |
| HTTP     | 超文本传输协议，使用 80 端口。                               |
| Telnet   | 一种用于远程登陆的端口，使用 23 端口，用户可以以自己的身份远程连接到计算机上，可提供基于 DOS 模式下的通信服务。 |

| 基于 UDP                             | 功能                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| DNS                                  | 域名解析服务，将域名地址转换为 IP 地址。DNS 用的是 53 号端口。 |
| SNMP                                 | 简单网络管理协议，使用 161 号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。 |
| TFTP (Trival File Transfer Protocal) | 简单文件传输协议，该协议在端口 69 上使用 UDP 服务。          |

#### 应用场景：

* TCP 应用在要求传输数据可靠的情况下，如文件传输、邮件传输等。

* UDP 应用在要求通信速度但对可靠性要求比较低的场景，如语音、视频等。

#### 怎么用 UDP 实现 TCP？

在应用层保证数据传输可靠，添加序号确认机制，确保数据发送成功，添加发送和接收缓冲区，用于超时重传。

详细说明：发送端发送数据时，生成一个随机序号 x。数据到达接收端后放入接收端缓存，并发送一个`ack=x`的包确认数据接收成功。发送端收到了`ack`包后，删除缓冲区对应的数据。设置一个超时时间，判断是否需要重传数据。

目前已经有了实现 UDP 可靠运输的机制 —— UDT：主要用于高速广域网海量数据传输，是应用层协议。