## HTTP

### HTTP 模型

HTTP 由请求和响应构成，是一个标准的客户端服务器模型 (B/S)。HTTP 协议永远都是客户端发起请求，服务器回送响应。

<img src="/Users/licheng/Documents/Typora/Picture/image-20200716084917662.png" alt="image-20200716084917662" style="zoom: 67%;" />

HTTP (超文本传输协议) 是一个基于请求与响应模式的、无状态的 (不保留连接的有关信息)、应用层的协议，常基于 TCP 的连接方式。

### HTTP 请求

HTTP 请求报文是由三部分组成：请求行、请求头部、请求正文。

#### 请求行

请求行包括：请求方法字段、URL 字段、HTTP 协议版本字段。它们用空格分隔。

例如，GET /index.html HTTP/1.1。

##### GET

获取 URL 指定的资源，当点击网页上的链接或者通过在浏览器的地址栏输入网址来浏览网页的，使用的都是 GET 方式。

使用 GET 方法时，请求参数和对应的值附加在 URL 后面，利用一个问号 ("?") 代表 URL 的结尾与请求参数的开始，但传递参数长度受限制，一般最多只能识别 1024 个字符，所以如果需要传送大量数据的时候，不适合使用 GET 方式。

##### POST

POST 方法将请求参数封装在 HTTP 请求正文中，以名称/值的形式出现，可以传输大量数据，这样 POST 方式对传送的数据大小没有限制，而且也不会显示在 URL 中，更加安全。

> GET 和 POST 区别：
>
> * GET 将请求信息放在 URL 中并且对长度有限制，POST 是把请求信息放在报文中，所以 POST 方法更安全且对传输数据大小没有限制。
>* GET 可以保证幂等性，POST 不保证。
> * GET 可以被缓存、被存储 (书签)，而 POST 不行。
>

##### HEAD

HEAD 通常用于查看某个页面的状态，服务器收到 HEAD 请求后只返回响应头，而不会返回响应内容，提高了传输效率。

##### PUT

用来上传文件，在请求报文的主体内容中包含文件内容，保存到请求 URL 指定的位置，http1.1 的 PUT 方法自身不带验证机制，任何人都可以请求，上传文件，会有安全问题。

##### DELETE

删除服务器上某个资源

##### OPTIONS

查询服务器支持的请求方法

##### TRACE

可以对请求消息的传输路径进行追踪

##### CONNECT

要求在与代理服务器通信时建立隧道，使用隧道进行 TCP 通信。主要使用 SSL (安全套接层) 和 TLS (传输层安全) 将数据加密后通过网络隧道进行传输。

#### 请求头部

请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号 “:” 分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：

User-Agent：产生请求的浏览器类型。

Accept：客户端可识别的内容类型列表。

Host：请求的主机名，允许多个域名同处一个 IP 地址，即虚拟主机。

### HTTP 响应

HTTP 响应报文也是由三部分组成：状态行、响应头部、响应报文 。

#### 状态行

HTTP 状态行包括协议版本、状态码、状态码描述字段。他们之间由空格分隔。

例：HTTP1.1 200 OK

##### 状态码

* 1xx：指示信息–表示请求已接收，继续处理。
* 2xx：请求成功。
  * `200 OK`：客户端请求成功。
* 3xx：重定向。
  * 301：永久性重定向。
  * 302：暂时性重定向。
  * 304：服务器会比较 If Modified Since 和文件的 Last Modified，如果相同，说明文件没有改变，就返回 304。
* 4xx：客户端错误。
  * `400 Bad Request`：客户端请求有语法错误，不能被服务器所理解。
  * `401 Unauthorized`：请求未经授权。
  * `403 Forbidden`：服务器收到请求，但是拒绝提供服务。
  * `404 Not Found`：请求资源不存在。
* 5xx：服务器端错误。
  * `500 Internal Server Error`：内部服务错误。
  * `502 Bad Gateway`
  * `504 Bad Gateway timeout`

**重定向与转发的区别？**

转发是服务器行为，重定向是客户端行为。

转发过程：浏览器发送 http 请求 -> web 服务器在内部完成请求处理和转发动作 -> 将目标资源发送给客户。转发行为是浏览器只做了一次访问请求。

重定向过程：浏览器发送 http 请求 -> web 服务器接受后发送 302 状态码响应及对应新的 location 给浏览器 -> 浏览器发现是 302 响应，则自动再发送一个新的 http 请求到新的位置 -> 服务器返回资源给浏览器。重定向行为是浏览器做了至少两次的访问请求的。

#### 响应头部

与请求头部类似，为响应报文添加了一些附加信息。

常见响应头部如下：

Server：服务器应用程序软件的名称和版本。

Content-Type：响应正文的类型 (是图片还是二进制字符串)。

Content-Length：响应正文长度。

Content-Charset：响应正文使用的编码。

Content-Encoding：响应正文使用的数据压缩格式。

Content-Language：响应正文使用的语言。

### HTTP 工作过程

#### DNS 解析

DNS 解析就是将输入的 URL 地址转换为 IP 地址的过程。

迭代查询：本地缓存 (浏览器缓存 -> 系统缓存)，本地域名服务器，根域名服务器，顶级域名服务器，权威域名服务器。

#### 建立 TCP 连接

客户端 (浏览器) 通过 TCP 传输协议与服务器建立 TCP 连接。

#### 发送 HTTP 请求

发送 HTTP 请求的过程就是构建 HTTP 请求报文并通过 TCP 协议发送到服务器指定端口 (HTTP 协议 80/8080，HTTPS 协议443)。

请求始于应用层，会先构成一个 HTTP 请求报文，然后将这个报文传到传输层，传输层的 TCP 协议会将 HTTP 报文切成大小合适的块，每一块加上一个 TCP 头，打包成一个 TCP 报文，在把它们传到网络层，网络层采用的是 IP 协议，IP 协议会再次对数据进行包装，加上一个 IP 头，然后数据就要开始真正的在物理链路上进行传输了，IP 协议会搜索对方的地址，一边中转一边将数据传送给目标服务器。根据 IP 地址找到服务器后，再经过一次以上过程的逆过程，服务器最终会收到我们的请求。

#### 服务器处理请求并返回 HTTP 报文

服务器从固定的端口接收到 TCP 报文 (这一部分对应于编程语言中的 socket)，它会对 TCP 连接进行处理，对 HTTP 协议进行解析，并按照报文格式进一步封装成 HTTP Request 对象，供上层使用。

这一部分工作一般是由 Web 服务器去进行，我使用过的 Web 服务器有 Tomcat。

#### 浏览器解析渲染页面

浏览器收到 HTML、CSS、JS 文件后，把页面呈现到屏幕上的过程。

### HTTP 1.0/1.1/2.0 区别

#### HTTP 1.0 与 HTTP 1.1

* HTTP 1.0 默认使用短链接。适合网页，点击量比较大的情况。HTTP 1.1 默认使用长连接，长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。

  通过 keep Alive 实现，一段时间没有响应之后，服务器发送一个探测报文，如果有回复，不关闭连接，如果没回复，关闭。

* HTTP 1.1 在请求头部加了 Range，允许请求某个资源的某个部分，返回状态码 206。HTTP 1.0 每次都会发送全部的页面和数据。

* HTTP 1.1 支持只发 header 不带 body，如果服务器认为客户端有权利访问，返回 100，否则返回 401，客户端可以接到 100 后再把 body 发过去，接到 401 就不发了，这样比较节省带宽。

* HTTP 1.1 支持 Host 域，在一台物理服务器上可以存在多个虚拟主机共享一个 IP 地址。HTTP 1.0 每台计算机只能绑定一个 IP 地址。

#### HTTP 2.0

* HTTP 2.0 会对 header 数据进行压缩，这样数据体积小了，在网络上传输就会更快。

* HTTP 2.0 使用二进制格式解析，而抛弃了 ASCII 码，提升了解析效率。

* HTTP 2.0  使用了多路复用的技术，做到同一个连接并发处理多个请求。

### HTTP 的缺点

* HTTP 通信使用明文，容易被窃听。
* 无法证明报文的完整性，有可能遭遇篡改。
* 不验证通信双方的身份，可能遭遇伪装。

## HTTPS

HTTPS 是在 HTTP 上建立 SSL 加密层，对传输数据进行加密，是 HTTP 协议的安全版。HTTPS 主要作用是：

* 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全。
* 对网站服务器进行真实身份认证。

> SSL：Secure Socket Layer 安全套接层
>
> TLS：Transport Layer Security 安全传输层协议
>
> TLS 是 SSL 的新版本，SSL 已经基本淘汰。

#### HTTPS 连接建立过程（四次握手）

1. 客户端先发送自己支持的加密协议以及版本信息。
2. 服务器端选择合适的加密协议，返回数字证书 (证书中有公钥)。
3. 客户端接收证书后首先验证证书的合法性 (使用签发机构的根证书验证)，然后生成一个随机数 (对称秘钥)，然后使用证书中的公钥对随机数加密，发送到服务器。
4. 服务器使用私钥解密，获取对称秘钥，使用对称秘钥加密数据并发送到客户端。
5. 客户端使用对称秘钥解密数据，开始 SSL 通信。

#### HTTPS 加密方式

TLS 的基本工作方式是，客户端使用非对称加密与服务器进行通信，实现身份验证，然后使用对称加密算法对信息以及信息摘要加密通信，不同的节点之间采用的对称密钥不同，从而可以保证信息只能通信双方获取。

##### 对称加密

加密和解密都是使用的同一个密钥。

对称加密的特点是信息传输 1 对 1。缺点是服务器和 N 个客户端通信，需要维持 N 个密码记录，且缺少修改密码的机制。

常见的算法有 DES、RC4、RC5、IDEA。

##### 非对称加密

加密和解密使用不同的密钥，密钥成对出现，分别称为公钥和私钥。公钥加密的信息只能私钥解开，私钥加密的信息只能公钥解开。

非对称加密的特点是信息传输 1 对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信，但服务器发出的信息能够被所有的客户端解密。但该算法的计算复杂，加密速度慢。

常见的算法有 RSA，DSA，DH。

##### 散列算法

散列变换是指把文件内容通过某种公开的算法，变成固定长度的散列值。

该类函数特点是函数单向不可逆、对输入非常敏感、输出长度固定，针对数据的任何修改都会改变散列函数的结果，主要用于验证数据是否被篡改、验证数据的完整性。

常见的有 MD5、SHA、Base64，CRC。

#### HTTPS 身份验证

##### RSA 身份验证的隐患

身份验证和密钥协商是 TLS 的基础功能，要求的前提是合法的服务器掌握着对应的私钥。但 RSA 算法无法确保服务器身份的合法性，因为公钥并不包含服务器的信息，存在安全隐患。

* 客户端 C 和服务器 S 进行通信，中间节点 M 截获了二者的通信；
* 节点 M 自己计算产生一对公钥 pub_M 和私钥 pri_M；
* C 向 S 请求公钥时，M 把自己的公钥 pub_M 发给了 C；
* C 使用公钥 pub_M 加密的数据能够被 M 解密，因为 M 掌握对应的私钥 pri_M，而 C 无法根据公钥信息判断服务器的身份，从而 C 和 M 之间建立了"可信"加密连接;
* 中间节点 M 和服务器 S 之间再建立合法的连接，因此 C 和 S 之间通信被 M 完全掌握，M 可以进行信息的窃听、篡改等操作。
* 另外，服务器也可以对自己的发出的信息进行否认，不承认相关信息是自己发出。


因此该方案下至少存在两类问题：中间人攻击和信息抵赖。

##### 身份验证 CA 和证书

解决上述身份验证问题的关键是确保获取的公钥途径是合法的，能够验证服务器的身份信息，为此需要引入权威的第三方机构 CA。CA 负责核实公钥的拥有者的信息，并颁发认证"证书"，同时能够为使用者提供证书验证服务，即 PKI 体系。

基本的原理为，CA 负责审核信息，然后对关键信息利用私钥进行"签名"，公开对应的公钥，客户端可以利用公钥验证签名。CA 也可以吊销已经签发的证书，基本的方式包括两类 CRL 文件和 OCSP。CA 使用具体的流程如下：

* 服务方 S 向第三方机构 CA 提交公钥、组织信息、个人信息 (域名) 等信息并申请认证；

* CA 通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等；

* 如信息审核通过，CA 会向申请者签发认证文件-证书。

  证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。

  签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA 的私钥对信息摘要进行加密，密文即签名。

* 客户端 C 向服务器 S 发出请求时，S 返回证书文件。

* 客户端 C 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA 的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即公钥合法。

* 客户端然后验证证书相关的域名信息、有效时间等信息。

* 客户端会内置信任 CA 的证书信息 (包含公钥)，如果 CA 不被信任，则找不到对应 CA 的证书，证书也会被判定非法。

在这个过程注意几点：

* 申请证书不需要提供私钥，确保私钥永远只能服务器掌握。

* 证书的合法性仍然依赖于非对称加密算法，证书主要是增加了服务器信息以及签名。

* 内置 CA 对应的证书称为根证书，颁发者和使用者相同，自己为自己签名，即自签名证书（为什么说"部署自签SSL证书非常不安全"）

* 证书=公钥+申请者与颁发者信息+签名。

#### HTTP 与 HTTPS 的区别

* HTTPS 需要到 CA 申请证书，HTTP 不需要。
* HTTPS 密文传输，HTTP 明文传输。
* HTTPS 默认使用 443 端口，HTTP 使用 80 端口。
* HTTPS = HTTP + 加密 + 认证 + 完整性保护，比 HTTP 安全。
