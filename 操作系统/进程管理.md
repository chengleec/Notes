### 进程和线程

* 进程：系统进行资源分配的基本单位。
* 线程：进程的一个执行单元，是 CPU 调度和分配的基本单位。 

#### 进程与线程的区别

* 进程是资源分配的基本单位，线程不拥有资源，但可以访问隶属进程的资源。
* 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低。
* 线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC (Inter-Process Communication)。

### 进程状态

<img src="/Users/licheng/Documents/Typora/Picture/image-20200819085109096.png" alt="image-20200819085109096" style="zoom:67%;" />

就绪状态是指进程仅缺少 CPU，只要获得 CPU 资源就立即执行；而阻塞状态是指进程需要其他资源或者等待某一事件，如 IO 请求。

### 进程通信

不同进程之间的地址空间是相互隔离的，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程 1 把数据从用户空间拷到内核缓冲区，进程 2 再从内核缓冲区把数据读走，内核提供的这种机制称为 IPC。

#### 管道

管道的实质是一个内核缓冲区，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据，中间介质是文件。

管道是半双工的，数据只能向一个方向流动，而且只能用于父子进程或者兄弟进程之间 (具有亲缘关系的进程)。

#### 有名管道

有名管道与管道的区别在于它提供了一个路径名与之关联，即使进程之间不存在亲缘关系，只要可以访问该路径，就能够通过有名管道相互通信。

有名管道的名字存在于文件系统中，数据存放在内存中。

#### 消息队列

消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。 

发送进程添加消息到队列的末尾，接收进程在队列的头部接收消息，消息一旦被接收，就会从队列中删除。

与管道的区别是它可以独立于发送和接收进程存在，只有内核重启或者显示的删除消息队列，他才会消失。而且接收进程可以选择自己接收的数据类型。

#### 共享内存

共享内存就是允许多个进程可以直接读写同一块内存空间，是最快的 IPC 形式。当一个进程改变了这块地址中的内容的时候，其它进程都会察觉到这个更改。

但是共享内存没有任何的同步与互斥机制，所以要使用信号量来实现对共享内存的存取的同步。

#### 信号量

信号量实际上是一个计数器，可以用来控制多个进程对共享资源的访问，通过 PV 操作实现。

#### 信号

信号是 Linux 系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。如 `ctrl+c` 会产生一个程序终止信号 `SIGINT`，shell 下执行 `kill -9` 命令会产生一个进程结束信号 `SIGKILL`。

### 线程同步

同步是指多个线程访问共享资源的时候，对线程进行调度，防止一起访问共享资源时出错。因为进程相互独立，没有共享资源，也就不需要进程同步。

* 互斥量：通过 Synchronized/Lock 锁机制实现线程访问共享资源的同步。

* 信号量：控制同一时刻访问共享资源的最大线程数量。

* 事件：通过 Wait/Notify 通知操作来保持多线程同步，还可以方便的实现多线程优先级的比较操作。

### 进程调度算法

* 周转时间 = 完成时间 - 到达时间
* 响应时间 = 首次运行时间 - 到达时间

#### First Come First Serverd (FCFS)

先来先服务，按照任务到达的时间依次执行，一个任务执行完了再执行下一个。

如果先执行了一个先到达的长耗时任务，会导致后到达的短耗时任务的周转时间变长，增加系统的平均周转时间。

#### Shortest Job First (SJF)

最短作业优先，先调度估计运行时间最短的进程。每次从就绪队列中挑选估计服务时间最短的进程分配 CPU 时间片。

长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

#### Shortest Time-to-Completion First (STCF)

最短剩余时间优先，先调度估计剩余运行时间最短的进程。

该算法首先按照短作业优先原则运行，在该作业运行期间，一旦有新作业到达系统，并且该新作业的服务时间比当前运行作业的剩余服务时间短，则发生抢占；否则，当前作业继续运行。

该算法确保一旦新的短作业或短进程进入系统，能够很快得到处理。

#### Round-Robin (RR)

时间片轮转，一个进程运行一个 CPU 时间片就切换下一个进程，大家轮着来。

由于要在多个任务之间进行切换，所以存在上下文切换的时间损耗。

#### Multi-Level Feedback Queue (MLFQ)

时间片轮转算法对于需要运行较长时间的进程很不友好，假设有一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。因此发展出了多级反馈队列的调度方式。

它会设置了多个就绪队列，每个队列时间片大小都不同，1, 2, 4, 8, ... 呈指数增长。如果进程在第一个队列没执行完，就会被移到下一个队列继续执行。这样做的好处是可以减少上下文切换的时间。

每个队列优先权也不同，最上面的优先权最高。可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

<img src="/Users/licheng/Documents/Typora/Picture/image-20200625161958235.png" alt="image-20200625161958235" style="zoom:50%;" />